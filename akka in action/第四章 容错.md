# 第四章 容错

本章包括的内容：

1. 自愈系统
2. 让它崩溃
3. Actor的生命周期
4. 管理
5. 故障恢复策略

本章介绍了使应用程序更具弹性的Akka工具。 介绍了"let-it-crash"的原则，包括监督、检测和Actor生命周期相关的内容。 当然，我们也会看一些例子，展示如何将它们应用于典型的故障场景。

## 4.1 什么是容错

首先让我们看看什么是容错，为什么要写代码去包容错误。 理想状态下，系统总是可用的，并且保证每个操作都成功。 只有俩个方法可以达到这种理想状态，一是永远不失败，二是失败后可以恢复，当然也要保证恢复不失败。 在大多数框架下，所能做的仅仅是利用捕捉机制，当未知错误发生时尽快终止应用。即使程序试图提供恢复策略，测试也是很困难的，而且为了保证恢复不失败，又增加了一层复杂度。 过程式编码中，每做一件事情都需要返回码，对照可能的故障列表进行检查。 异常处理成为了现代编程语言的标准配置，用一种简便的方式，提供所需的各种恢复方法。虽然不需要在每行代码上都进行故障检查，但仍需要将故障传播到各种异常处理代码，这方面没有显著的改善。

无故障系统在理论上听起来不错，但是建立一个高可用的分布式系统却不是一件简单的事情。 主要的原因是系统的很多部分不是我们能控制的，而且这些部分很可能出问题。 再有一个普遍的问题是：多个合作者之间通过使用共同的组件进行交互，出了问题，谁来负责，也不是很清楚。**网络是一个很好的例子，资源潜在不可用：它可能会随时掉线或者部分可用，如果我们想继续，我们就需通过其他路径进行通信或者过一会再重试。** 我们可能依赖第三方服务，它随时都有可能不可用。 运行软件的服务器可能会失败或无法使用，甚至直接遇到硬件故障。 显然，你不能神奇地让服务器从灰烬中重新出现，或者自动修复一个损坏的磁盘以保证对其进行写入。在设备众多的电信界，设备故障太平常了，如果没有良好的故障应对措施，将无法提供有效的访问，于是出现了"let-it-crash"的思想。

既然不能阻止所有的故障的发生，我们就要采取一定的措施，要铭记以下几点：

1. **Things break**。系统需要容错，这样才能保持可用性并继续运行。可恢复故障不应触发灾难性故障。
2. ~~在一些情况下，尽量长的保持系统的主功能可用是可以接受的。同时失败的部分被停止并清理出系统，确保不会重启系统或产生不可预知的结果。~~
3. ~~其他一些情况下，有些组件很重要，就需要有备份（active backups），当主组件出问题时，可以快速的替代主组件。~~
4. ~~在系统的某些部分发生故障时，不应该使整个系统崩溃，所以我们需要一种方法来隔离特定的故障，让我们可以稍后处理。~~

当然，AKKA的工具箱不包含容错的银弹， 我们仍然要处理具体的失败。下面这些AKKA的特性是我们容错时需要的：

==TODO：表格 4-1 可用的容错策略==

你可能会说，等等，为什么我们不用老方法或者异常来恢复故障？通常exception用于回退一系列行为，防止状态不一致，而不是恢复故障。 接下来，让我们看看用异常进行故障恢复是多么费劲。

### 4.1.1 普通对象和异常

让我们来看个从多个线程接收日志的实例程序。 从文件中读取信息，并解析成行存入数据库。 某个程序监视文件的增加，并通知其他线程处理这些新文件。 下面这个图给出了程序的概述，并强调了虚线圈着的部分。

![日志处理程序](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-77_1.jpg)

如果数据库连接断了，我们希望建立一个到另外一个数据库的新连接，而不是退出。 如果数据库连接出现了故障，我们希望断开连接，阻止程序的其他地方继续使用它。 某些情况下，我们希望重连，以恢复当前连接的错误状态。 下面的伪代码就可以说明潜在的问题。 我们先看看用标准的exception来处理重连同一个数据库。

首先所有被多线程使用的对象都启动。 启动后它们就可以处理监控程序发现的新文件。 我们启动writer（写数据库的对象，后面统一叫writer）。 下图显示了创建writer的过程。

![创建writer](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-78_1.jpg)

> 所有writer依赖的参数都传给了构造函数，创建writer的线程吧url传给了database factory，用来创建一个连接。 下面我们来设置日志处理进程，每个都有一个writer的引用，如下图所示

![创建日志处理](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-78_2.jpg)

> 下面的图显示了实例程序中各对象的调用关系。

![调用栈](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-79_1.jpg)

当监视程序发现多个日志文件时，会同时启动多个线程调用上面的流程。 下图是抛出DbBrokenConnectionException异常时的调用栈，当收到异常时，我们应该建立到另一个数据库的连接。 我们省略了细节，只给出了对象间的调用关系。

![调用栈](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-80_1.jpg)

我们更喜欢用一正确的数据库连接从DbBrokenConnectionException异常中恢复，而不是把异常从栈中抛出。 我们首先面对的问题是，如果不破坏现在的设计，我们就无法编码创建新的数据库连接。 同时我们也没有足够的信息创建新的连接，因为我们不知道哪些连接是好的，哪些连接发生了异常。

> 重新建立新的连接和提供连接的信息，会打乱我们原有的简单设计和一些基本的最佳实践，比如封装、控制反转、单一责任等。 (Good luck at the next code peer review with your clean coding colleagues!) 我们只是想失败的地方，加入异常处理和记录日志的逻辑。 即使我们找到一个地方可以重新建立连接，我们也必须非常小心，确保没有其他的线程正在使用这个失败的连接，否则就会有数据丢失。 在java中有三个连接池， only one even has a working implementation of dead connection removal on another thread. 这显然与我们现在的工具不能很好的相容。
>
> 此外，线程间通信异常不是一个标准的功能，你必须自己建立。 让我来看看容错的要求，即使我们有机会来容错，我们也忍受不了。

- 故障隔离：多个线程可能会同时抛出异常，这使得隔离很困难。我们必须增加一些锁机制。 从对象链中移除失败的连接也很困难，应用不得不重写。这里没有标准的支持让我们移除连接，所有我们必须在对象内部建立一定程度的间接方法。
- 结构：对象直接的结构非常简单、直接，默认不提供取出对象的支持。
- 冗余：像上面例子看到的那样，当一个异常从调用栈抛出后，你可能会丢失故障恢复的上下文或者数据输入的上下文。
- 更换：没有更换调用栈上对象的默认策略，你必须自己想办法。依赖注入框架可以为此提供一些支持，但是如果是对对象的直接引用而不是间接引用，你就麻烦了。 你最好要确保修改对象的地方是多线程安全的。
- 重启：跟更换类似，恢复对象的初始状态，也没有自动提供，你必须通过一定程度的间接方式来提供。 所有对象之间的关系必须要重新定义。 如果对象的依赖关系也要重启（也就是说日志处理程序会抛可），而且要有序，事情就更复杂了。
- 对象的生命周期：在构造之后垃圾回收之前，对象是存在的，其他任何机制，你必须自己实现。
- 挂起：当捕获到异常并从栈上抛出时，输入数据或者上下文会丢失或无效，你必须自己实现一种缓冲器来保存这些信息，直到故障恢复。 如果代码是由多线程来调用的，你必须加锁，防止同时有多个异常发生。 你必须实现一个方法在故障恢复后，用保存的数据进行重试。
- 关系分离：异常处理跟正常流程交织在一起，无法定义独立的处理流程。

> 这看起很失望，要想让一切正常运行是多么复杂和痛苦。 这里好像缺少了些根本性的功能，可以使容错变得简单。

- 在对象不可用时，重建对象和它的引用，作为框架的首要功能提供。
- 对象之间直接通信，所有很难隔离它们。
- 故障恢复的代码跟功能代码混在一起。

> 还好，我们有个简单解决方案。我们已经看了一些actor的功能，这能够帮我们简化问题。 actor可被props对象建立和重建，这是actor系统的一部分，而且actor之间的通信是通过actor的引用而不是直接通信。 下一节我们就看看actor系统是如何解耦功能代码和故障恢复代码，还有在故障恢复的过程中actor系统是如何挂起和重启actor的。

### 4.1.2 使其崩溃

在前一节中我们已经看到，用普通对象和异常处理来建立容错系统是非常复杂的工作。 下面来看看`Actor`是如何简化这个工作的。 当`Actor`在处理消息时发生异常会如何处理？ 我们已经讨论过，不能将容错代码和业务处理混在一起，因此在业务逻辑所在的`Actor`中，捕获异常也不是一个选择。

Akka Actor 没有用一个流程来处理正常代码和故障恢复代码，而是采用了两个不同的流程：一个用于正常逻辑，一个用于故障恢复逻辑。 正常流程由处理正常消息的actors组成，故障恢复流程里的actors监控正常流程中的actors，这些监控actors被称作**supervisor**。==图4.6==显示了supervisor监控actor的流程。

![正常和故障恢复](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-83_1.png)

我们做的仅仅是==让actor崩溃==，而不是在actor内部捕获异常。 处理消息的actor只包含处理正常逻辑的代码，没有异常处理和故障恢复的代码，所以不是故障恢复的一部分，这使得结构更加清晰。 崩溃actor的邮箱会被挂起，直到故障恢复流程中的supervisor决定如何处理这个异常为止。 那如何让一个actor成为supervisor呢？Akka选择采用父母监管(*parental supervision*)的方法，只要这个actor创建了其他actor，它就自动变为supervisor。==supervisor不捕获异常，而是监督失败的原因并给出一些策略==。 supervisor也不尝试修正actor或者恢复actor的状态。 它只是简单地决定如何恢复，并触发对应的策略。 supervisor为如何操作actor提供了4个选项：

- ~~重启：actor会通过它的props重建。重启之后它会继续处理它的消息。 由于应用程序的其他部分是用actor的引用进行通信，所以新的actor实例会自动获取下一条消息。~~
- ~~恢复：同样的actor实例继续处理消息，忽略崩溃。~~
- ~~停止：actor必须停止，它不能再进行消息处理。~~
- ~~上报：supervisor不知道该如何处理，上报给自己的supervisor。~~

图4.7给出了日志处理程序使用actor时，可供选择的错误处理策略。 它显示了在某个特定崩溃发生时，supervisor可能采取的处理行为。

![日志处理程序的正常和故障恢复流程](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-84_1.png)

图4.7显示了日志处理程序的容错方案，至少是==数据库连接异常==的容错方案。 当`dbWriter` actor发生错误时，抛出`DbBrokenConnectionException`异常，`LogProcessingSupervisor`会重新创建一个`dbWriter`。

我们会采取一些特殊的步骤来恢复==失败的消息==，在后面介绍restart的实现细节时，将会详细讨论之。 可以这么说，大多数时候，我们不想重新处理之前导致错误的消息，因为它很可能还会发生同样的错误。例如：日志处理程序碰到一个损坏的文件，重新处理损坏的文件还是会失败，这将导致**==poisoned mailbox==**，结果是进入不断重试的死循环，无法处理其他消息。因此，Akka选择在重新启动后不再向邮箱提供失败的消息，但是如果你确信消息不会导致错误，则可以自己这样做，稍后我们将讨论。好消息是，如果一个作业正在处理数万条消息，其中一条消息已损坏，则默认行为将导致所有其他消息被正常处理；也就是一个损坏的文件不会导致灾难性的失败，不会抹去之前做的所有工作（并继续剩下的工作）。

图4.8 当supervisor使用==重启==策略时，如何将崩溃的`dbWriter`替换成新的实例。

![捕获DbBrokenConnectionException并重启](https://withshenhui.gitbooks.io/akka-in-action-cn/content/figures/file-85_1.png)

让我们重温一下“let-it-crash”的有点：

- 故障隔离：supervisor决定如何终止actor，将actor从系统中移除。
- ~~结构：actor系统的层次关系使得一个actor实例被移除后，其他的actor不受影响。~~
- ~~冗余：一个actor可以被另一个替换。例子中，当actor实例的数据库连接发生异常时，可以用连接另外一个数据库的actor替换。 这些都有supervisor来决定。 另外一种做法是把消息路由到负载均衡的其他实例，第九章会介绍。~~
- 更换：actor可以通过它的`Props`重建。 supervisor可以决定用一个新的actor实例替换出错的actor实例，而无须知道重建actor的任何细节的。
- 重启：通过restart实现。
- 生命周期：一个actor是一个==活动==的组件，它可以被启动、停止和重启。 下一节我们详细介绍生命周期。
- 挂起：当actor崩溃，它的邮箱会被挂起，直到supervisor决定如何处理这个actor。
- 关注点分离：actor的正常消息处理和监控故障恢复流程是正交的，可以完全独立地定义和发展。

后面几节，我们将介绍生命周期和监管策略的编码细节。