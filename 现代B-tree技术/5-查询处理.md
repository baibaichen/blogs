## 5. 查询处理

B-tree索引只有用到才有价值，这需要查询优化器考虑到使用它们的查询执行计划，查询执行时真正利用它们。**因此，本节总结了通常与B-tree索引结合使用的查询执行技术**。在进入各个小节==讲解==使用B-tree的查询处理技术之前，先简要介绍查询处理及其两个主要组件：查询优化和查询执行。自动优化查询的需求和机会来自于使用非过程性数据库语言（如SQL）的用户接口和物理数据独立性。

术语**物理数据独立性**描述了逻辑数据（表和物化视图）与物理数据（堆文件和索引）的分离。**表**包含**由名称标识的列**和**由唯一主键标识的行**，行包含列值。文件和索引包含由堆中的**记录标识符**或索引中的**唯一搜索键**标识的记录，记录包含字段。当然，行和记录之间、列和字段之间存在关系，但物理数据独立性使得这种关系相当松散。

> ==TODO：==，图5.1

利用这些松散关系可产生许多优化机会。在上面使用的术语中，表和索引之间、逻辑行和物理记录之间可能存在多对多关系。有趣的是，数据库对象之间的实体关系建模类似于用户数据库的实体关系建模，并且可以使用标准技术导出所需的元数据表。当然，不仅逻辑数据库设计，物理数据库设计也适用于目录表，包括在内存缓存中放置目录信息的数据。

> 1. 原文这里的**schema concepts**翻译成**数据库对象**，schema本来就有数据库的意思，在MySQL中`create schema`等同于`create database`。
>
> 2. **entities and relationships**，就是ER数据模型

图5.1显示了表和索引这两个实体类型，及它们的属性：列和索引字段。在大多数数据库管理系统中，表和索引之间是一对多关系，即一个表可以有多个索引，但一个索引只能属于一个表。多对多关系表示支持**联接索引**[123]。索引和B-tree之间可以是一个简单的一对一关系，不需要在ER图中进一步详细说明；如果每个索引可以划分为多个B-tree，则为一对多关系；或者，如果是==**主从聚集**==，则是多对一关系，例如**合并B-tree**[49]。

根据软件系统提供的功能，**数据库的物理设计**可能仅限于索引调整，也可能利用水平和垂直分区，面向行或列的存储格式，压缩和位图编码，页面和索引中的空闲空间，排序顺序和主从聚集，以及许多其他选项[38]。考虑到自动化的趋势，在**数据库的物理设计**中，似乎也应包括自动化，例如，自动创建和维护统计信息（直方图）和软约束[60]、自动创建和优化索引、以及自动创建具有自己的索引，统计信息和软约束的物化视图。

由于数据库查询指定表，但查询执行计划访问索引，因此需要映射。物理数据独立性允许并要求在此映射中进行*选择*。查询优化是资源密集型的，传统的数据库分为**编译时查询优化**和**运行时查询执行**。除了访问路径选择，查询优化还选择执行算法（例如hash join或merge join）以及处理顺序（例如join顺序）。

这些*选择*在查询执行计划中==捕获==。 **查询执行计划**通常是棵树，但在**公共子表达式**的情况下，它可能是DAG（有向非循环图）。请注意，在查询优化期间可能会引入**公共子表达式**，例如，包括`distinct`关键字、含有多个聚合的查询，具有垂直或水平分区的表，以及大规模更新。

> ==TODO：==，图5.2

图5.2显示了一个简单的查询执行计划，数据结构由查询优化器在编译时构建，并由查询执行引擎在运行时解释执行。节点指定算法和所需的表达式，例如**谓词**、**排序子句**和**投影列表**。理想情况下将其编译成机器码，但在今天，编译成特殊用途的字节代码，然后在运行时解释执行似乎更为常见。

在大多数查询引擎的执行计划中，**控制流从消费者流向生产者，数据流从生产者流向消费者**。数据流单元可以是一条记录、一个“值包”[78]、一页，或任何其他被认为是在复杂性和性能之间良好折衷的数据单元。执行树中的控制流通常通过迭代器[39]来实现，从而产生自顶向下的控制流。一个例外是查询执行计划里有多个消费者共享的（公共）子计划，且需要嵌套迭代。这是由于复杂性或是存在索引（因而更加高效），所以查询优化器没有“展开”**嵌套SQL表达式**。如果查询执行在管道中使用多个线程，则自下而上控制通常似乎更合乎需要。管道中生产者和消费者之间的==流量控制==实际上使得它们没有区别。自下而上的线程启动似乎与自上而下的迭代器相矛盾，但事实上并非如此[40]。

<u>一些操作，最明显的是排序，输入和输出不重叠，许多情况下还存在中间步骤。这些算子的步骤描绘了计划阶段，例如，从一个**排序算子**（在其输出阶段）到**归并连接算子**，再到另一个**排序算子**（在其输入阶段）中的管道</u> 。称这些算子为“走走停停”算法，管道破坏器和其它类似的名称，它们在查询执行计划中出现显然会影响资源管理，如内存分配。

> ==TODO：==，图5.3

<u>图5.3将计划阶段添加到图5.2的查询执行计划中，这是因为排序是“走走停停”算子</u>。中间的计划阶段可选：如果输入大小和排序用到的内存使得仅需要单步合并，则可省略中间阶段。

大多数传统系统执行查询计划非常严格：查询优化器进行选择，查询执行引擎遵循这些选择。但查询执行期间也存在多种选择，从资源管理（例如，排序和hash join的工作空间大小）到执行计划的有限修改[84]，以及记录的自由路由[3]。运行时验证查询优化器采用的假设和估计，例如中间结果中的记录数和数据分布，使得查询执行期间进行选择受益。

区分B-tree索引与其他索引的一个特点是它支持有序检索。 索引项有序支持**范围谓词**和**多列索引中的多个谓词**。 中间查询结果的排序有助于索引到索引的导航、磁盘检索、集合操作（例如索引交集）、merge join、基于顺序的聚合和嵌套迭代。

- 因为描述式（非过程）的查询语言和物理数据独立性，查询优化器在编译时选择查询执行计划，即由查询执行算子组成数据流图。优化器选择执行计划是基于基数估计，以及不同查询表达式和执行计划的执行成本。
- 在查询执行计划中利用B-tree索引来检索（例如，查询文本中的文字查找）和有序扫描。
- 查询优化也可以提高索引更新（索引维护）的性能。

### 5.1 磁盘序扫描

我们现在转向特定的B-tree技术，以便在大型数据存储中高效地进行查询处理。

大多数扫描B-tree的操作由B-tree的结构引导，以便按索引的排序顺序进行输出（“索引序扫描”）。通过父节点和祖父节点中的信息，可以进行多层、多页预读。如果必须扫描B-tree中的所有叶子，则可通过B-tree的分配信息来引导扫描。许多系统都是在空闲空间管理的背景下保存这些信息，常以位图的形式存在。基于分配位图的扫描在存储设备上产生较少的查找操作（“磁盘序扫描”）。两种扫描方法都必须读取除叶子之外的B-tree分支节点，因此传输量上两者几乎没有差异。如果不需要排序输出，则磁盘序扫描通常更快。

根据B-tree的碎片以及索引序扫描所需的寻道操作数，即使所需的B-tree叶子数少于所有B-tree叶子数，磁盘序扫描可能更快。在碎片严重的情况下，磁盘序扫描加上显式排序可能比索引序扫描更快。

图5.4显示了一个小的，碎片严重的B-tree。从根到叶的搜索不受碎片的影响，但大范围查询或完整的索引序扫描必须频繁搜索，因此无法读取连续的磁盘段。由分配信息引导的磁盘序扫描可连续读取15页，甚至可以读取（然后忽略）两个未使用的页（第一行中间和第二行最右边）。

> ==TODO：==，图5.4

另一种加速扫描的技术是**协调扫描**[33,132]，这种技术通常（尽管不总是）与磁盘序扫描相关联。这种并发扫描的优化现在在几个数据库系统中得到运用。新扫描启动时，系统首先检查新扫描是否可按任意顺序消费数据，以及是否存在其它==的查询==正在扫描相同的数据。如果是，（两个）扫描则链接在一起，新扫描从老扫描当前的位置开始。老扫描完成后，新扫描必须重新开始扫描，以获取先前扫描跳过的数据。这种技术适用于任何数量的扫描，有时也被称为“旋转木马”扫描，因为每个数据消费者都会进行一次连续地主动扫描。此类扫描的潜在问题是并发控制（如果所有扫描器都锁定整个表、索引或等效项，这种方法最有效）和带宽。假设两个查询以非常不同的速度处理扫描的数据，比如由于（某个查询）具有用户定义函数的谓词，两个扫描应取消链接。

**协调扫描**更为复杂，它利用缓冲池中保留的页面进行初始化，这些页面由先前的活动（可能不是扫描）缓存，它们可能链接和取消链接多次，并通过相关性对未来所需的I/O进行排序以优化系统整体的吞吐量，相关性要考虑到共享的数量、每个查询剩余的工作量以及查询饥饿的危险度。为了减少管理工作，这些考虑因素应基于块或页面组，而不是单个页面。

另一方面对于索引碎片，智能预读技术可以提高按索引序扫描的性能。这些技术优化了分支节点中引用的多个子节点之间的读取顺序，以最小化存储设备中的查找操作。

随着内存大小的不断增加，以及越来越多的半导体数据存储（如闪存），在B-tree索引和数据库查询处理中，共享的**协调扫描**以及智能预取的重要性会越来越低。 然而为了充分利用多核，因为它们共享大型CPU缓存，将来仍可能需要这些技术。

- 如果不需有序输出或使用谓词，只是为了索引中的数据列，并且索引是碎片化的，那么由分配信息引导的磁盘序扫描可能比索引序扫描更快。

### 5.2 读取行数据

如果逻辑表及其行直接映射到**堆文件**或**主索引及其记录**，许多查询执行计划从二级索引获取记录引用（记录标识符或主索引中的键），然后为每行获取其他列。使用**索引嵌套循环连接**可以很容易地获取行数据，该算法较为通用，并不是只为了获取行数据， 因为**外层循环的每个输入**可以对应**内层循环任意数量的记录**（而不是只有一行）。









