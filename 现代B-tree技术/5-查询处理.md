## 5. 查询处理

B-tree索引只有用到才有价值，这需要查询优化器考虑到使用它们的查询执行计划，查询执行时真正利用它们。**因此，本节总结了通常与B-tree索引结合使用的查询执行技术**。在进入各个小节==讲解==使用B-tree的查询处理技术之前，先简要介绍查询处理及其两个主要组件：查询优化和查询执行。自动优化查询的需求和机会来自于使用非过程性数据库语言（如SQL）的用户接口和物理数据独立性。

术语**物理数据独立性**描述了逻辑数据（表和物化视图）与物理数据（堆文件和索引）的分离。**表**包含**由名称标识的列**和**由唯一主键标识的行**，行包含列值。文件和索引包含由堆中的**记录标识符**或索引中的**唯一搜索键**标识的记录，记录包含字段。当然，行和记录之间、列和字段之间存在关系，但物理数据独立性使得这种关系相当松散。

> ==TODO：==图5.1

利用这些松散关系可产生许多优化机会。在上面使用的术语中，表和索引之间、逻辑行和物理记录之间可能存在多对多关系。有趣的是，数据库对象之间的实体关系建模类似于用户数据库的实体关系建模，并且可以使用标准技术导出所需的元数据表。当然，不仅逻辑数据库设计，物理数据库设计也适用于目录表，包括在内存缓存中放置目录信息的数据。

> 1. 原文这里的**schema concepts**翻译成**数据库对象**，schema本来就有数据库的意思，在MySQL中`create schema`等同于`create database`。
>
> 2. **entities and relationships**，就是ER数据模型

图5.1显示了表和索引这两个实体类型，及它们的属性：列和索引字段。在大多数数据库管理系统中，表和索引之间是一对多关系，即一个表可以有多个索引，但一个索引只能属于一个表。多对多关系表示支持**联接索引**[123]。索引和B-tree之间可以是一个简单的一对一关系，不需要在ER图中进一步详细说明；如果每个索引可以划分为多个B-tree，则为一对多关系；或者，如果是==**主从聚集**==，则是多对一关系，例如**合并B-tree**[49]。

根据软件系统提供的功能，**数据库的物理设计**可能仅限于索引调整，也可能利用水平和垂直分区，面向行或列的存储格式，压缩和位图编码，页面和索引中的空闲空间，排序顺序和主从聚集，以及许多其他选项[38]。考虑到自动化的趋势，在**数据库的物理设计**中，似乎也应包括自动化，例如，自动创建和维护统计信息（直方图）和软约束[60]、自动创建和优化索引、以及自动创建具有自己的索引，统计信息和软约束的物化视图。

由于数据库查询指定表，但查询执行计划访问索引，因此需要映射。物理数据独立性允许并要求在此映射中进行*选择*。查询优化是资源密集型的，传统的数据库分为**编译时查询优化**和**运行时查询执行**。除了访问路径选择，查询优化还选择执行算法（例如hash join或merge join）以及处理顺序（例如join顺序）。

这些*选择*在查询执行计划中==捕获==。 **查询执行计划**通常是棵树，但在**公共子表达式**的情况下，它可能是DAG（有向非循环图）。请注意，在查询优化期间可能会引入**公共子表达式**，例如，包括`distinct`关键字、含有多个聚合的查询，具有垂直或水平分区的表，以及大规模更新。

> ==TODO：==图5.2

图5.2显示了一个简单的查询执行计划，数据结构由查询优化器在编译时构建，并由查询执行引擎在运行时解释执行。节点指定算法和所需的表达式，例如**谓词**、**排序子句**和**投影列表**。理想情况下将其编译成机器码，但在今天，编译成特殊用途的字节代码，然后在运行时解释执行似乎更为常见。

在大多数查询引擎的执行计划中，**控制流从消费者流向生产者，数据流从生产者流向消费者**。数据流单元可以是一条记录、一个“值包”[78]、一页，或任何其他被认为是在复杂性和性能之间良好折衷的数据单元。执行树中的控制流通常通过迭代器[39]来实现，从而产生自顶向下的控制流。一个例外是查询执行计划里有多个消费者共享的（公共）子计划，且需要嵌套迭代。这是由于复杂性或是存在索引（因而更加高效），所以查询优化器没有“展开”**嵌套SQL表达式**。如果查询执行在管道中使用多个线程，则自下而上控制通常似乎更合乎需要。管道中生产者和消费者之间的==流量控制==实际上使得它们没有区别。自下而上的线程启动似乎与自上而下的迭代器相矛盾，但事实上并非如此[40]。

<u>一些操作，最明显的是排序，输入和输出不重叠，许多情况下还存在中间步骤。这些算子的步骤描绘了计划阶段，例如，从一个**排序算子**（在其输出阶段）到**归并连接算子**，再到另一个**排序算子**（在其输入阶段）中的管道</u> 。称这些算子为“走走停停”算法，管道破坏器和其它类似的名称，它们在查询执行计划中出现显然会影响资源管理，如内存分配。

> ==TODO：==图5.3

<u>图5.3将计划阶段添加到图5.2的查询执行计划中，这是因为排序是“走走停停”算子</u>。中间的计划阶段可选：如果输入大小和排序用到的内存使得仅需要单步合并，则可省略中间阶段。

大多数传统系统执行查询计划非常严格：查询优化器进行选择，查询执行引擎遵循这些选择。但查询执行期间也存在多种选择，从资源管理（例如，排序和hash join的工作空间大小）到执行计划的有限修改[84]，以及记录的自由路由[3]。运行时验证查询优化器采用的假设和估计，例如中间结果中的记录数和数据分布，使得查询执行期间进行选择受益。

区分B-tree索引与其他索引的一个特点是它支持有序检索。 索引项有序支持**范围谓词**和**多列索引中的多个谓词**。 中间查询结果的排序有助于索引到索引的导航、磁盘检索、集合操作（例如索引交集）、merge join、基于顺序的聚合和嵌套迭代。

- 因为描述式（非过程）的查询语言和物理数据独立性，查询优化器在编译时选择查询执行计划，即由查询执行算子组成数据流图。优化器选择执行计划是基于基数估计，以及不同查询表达式和执行计划的执行成本。
- 在查询执行计划中利用B-tree索引来检索（例如，查询文本中的文字查找）和有序扫描。
- 查询优化也可以提高索引更新（索引维护）的性能。

### 5.1 磁盘序扫描

我们现在转向特定的B-tree技术，以便在大型数据存储中高效地进行查询处理。

大多数扫描B-tree的操作由B-tree的结构引导，以便按索引的排序顺序进行输出（“索引序扫描”）。通过父节点和祖父节点中的信息，可以进行多层、多页预读。如果必须扫描B-tree中的所有叶子，则可通过B-tree的分配信息来引导扫描。许多系统都是在空闲空间管理的背景下保存这些信息，常以位图的形式存在。基于分配位图的扫描在存储设备上产生较少的查找操作（“磁盘序扫描”）。两种扫描方法都必须读取除叶子之外的B-tree分支节点，因此传输量上两者几乎没有差异。如果不需要排序输出，则磁盘序扫描通常更快。

根据B-tree的碎片以及索引序扫描所需的寻道操作数，即使所需的B-tree叶子数少于所有B-tree叶子数，磁盘序扫描可能更快。在碎片严重的情况下，磁盘序扫描加上显式排序可能比索引序扫描更快。

图5.4显示了一个小的，碎片严重的B-tree。从根到叶的搜索不受碎片的影响，但大范围查询或完整的索引序扫描必须频繁搜索，因此无法读取连续的磁盘段。由分配信息引导的磁盘序扫描可连续读取15页，甚至可以读取（然后忽略）两个未使用的页（第一行中间和第二行最右边）。

> ==TODO：==图5.4

另一种加速扫描的技术是**协调扫描**[33,132]，这种技术通常（尽管不总是）与磁盘序扫描相关联。这种并发扫描的优化现在在几个数据库系统中得到运用。新扫描启动时，系统首先检查新扫描是否可按任意顺序消费数据，以及是否存在其它==的查询==正在扫描相同的数据。如果是，（两个）扫描则链接在一起，新扫描从老扫描当前的位置开始。老扫描完成后，新扫描必须重新开始扫描，以获取先前扫描跳过的数据。这种技术适用于任何数量的扫描，有时也被称为“旋转木马”扫描，因为每个数据消费者都会进行一次连续地主动扫描。此类扫描的潜在问题是并发控制（如果所有扫描器都锁定整个表、索引或等效项，这种方法最有效）和带宽。假设两个查询以非常不同的速度处理扫描的数据，比如由于（某个查询）具有用户定义函数的谓词，两个扫描应取消链接。

**协调扫描**更为复杂，它利用缓冲池中保留的页面进行初始化，这些页面由先前的活动（可能不是扫描）缓存，它们可能链接和取消链接多次，并通过相关性对未来所需的I/O进行排序以优化系统整体的吞吐量，相关性要考虑到共享的数量、每个查询剩余的工作量以及查询饥饿的危险度。为了减少管理工作，这些考虑因素应基于块或页面组，而不是单个页面。

另一方面对于索引碎片，智能预读技术可以提高按索引序扫描的性能。这些技术优化了分支节点中引用的多个子节点之间的读取顺序，以最小化存储设备中的查找操作。

随着内存大小的不断增加，以及越来越多的半导体数据存储（如闪存），在B-tree索引和数据库查询处理中，共享的**协调扫描**以及智能预取的重要性会越来越低。 然而为了充分利用多核，因为它们共享大型CPU缓存，将来仍可能需要这些技术。

- 如果不需有序输出或使用谓词，只是为了索引中的数据列，并且索引是碎片化的，那么由分配信息引导的磁盘序扫描可能比索引序扫描更快。

### 5.2 读取行数据

如果逻辑表及其行直接映射到**堆文件**或**主索引及其记录**，许多查询执行计划从二级索引获取记录引用（记录标识符或主索引中的键），然后为每行获取其他列。使用**索引嵌套循环连接**可以很容易地获取行数据，该算法较为通用，并不是只为了获取行数据， 因为**外层循环的每个输入**可以对应**内层循环任意数量的记录**（而不是只有一行）。

最简单的执行可能导致大量的随机I/O操作，这是仍然很常见的传统策略。因此，二级索引只对非常有选择性的查询有用。最近，在数据库查询执行方面的许多研究，都集中在没有二级索引的情况下扫描大表，例如使用**协调扫描**[33，132]、数据压缩[69，111]、列存储[122]以及对谓词评估的硬件支持（GPU或FPGA [37]）。下面的技术可能会移动盈亏平衡阈值，以有利于二级索引。

> ==TODO：==图5.5

图5.5说明了三个竞争计划在不同返回数据量下的执行成本，这些计划用于简单操作，即从表中选择一组数据。在左侧，表中的所有行都被查询谓词拒绝；在右侧，所有行都满足该谓词。**扫描表**（或包含所有行和列的数据结构）的成本几乎不变，与结果集大小无关。它需要每页或每块（页的连续序列）是连续I/O扫描。如果对结果集的基数估计不可靠（这种情况经常发生），这是最可靠的方案。另一个传统计划是使用二级索引（通常是B-tree）来获取满足查询谓词的**记录标识符**。这个计划对小结果集非常好，通常比**扫描表**快1000倍。但对大结果集，传统的执行技术非常昂贵，因为每个符合条件的数据都需要一次随机的I/O。目前认为列存储和列扫描优于传统的执行计划。它们非常健壮，比表扫描快，快的倍数等于==整行的大小==除以==给定查询真正需要的列的组合大小==，这个倍数通常在一个量级以上，特别是当列存储格式从压缩中受益，而传统的行式存储没有时。

当然，理想的情况是，这种技术可以为具有少量合格记录的谓词执行二级索引搜索，对具有大量合格记录的谓词执行列扫描，并可以在两者之间的整个范围内优雅降级。

- 二级索引可以比**表扫描**甚至**列扫描**更快地响应选择性查询。
- 除非查询优化器的基数估计在编译时非常准确，否则选择**具有可靠性能的计划**，而不是**预期性能更好的计划**。

### 5.3 覆盖索引

如果二级索引可以提供查询中需要的所有列，或者来自特定表的所有列，则无需从**堆文件**或**主索引**中获取记录。 这方面常见的术语是**index-only检索**或**覆盖索引**。后一术语可能令人困惑，因为不是由于索引本身的属性，而是索引和查询的组合在一起才能产生这种效果。

> ==TODO：==图5.6

图5.6显示了三表关联的查询执行计划，没有用到覆盖索引。在本例中，查询用到多对多关系，以**注册表**（enrollment ）为中间表，来关联**课程表**（course）和**学生表**（student）之间的关系。具体的SQL是：

```sql
  select 
    st.name 
  from 
    student as st, 
    enrollment as enr, 
    course as co 
  where 
    co.title = “biology 101” and 
    enr.course-number = co.course-number and 
    enr.student-identifier = st.student-identifier
```

这个三表查询需要两个**两表关联**。每个关联可能需要两个索引检索：第一，在二级索引中搜索会生成一个记录标识符；第二，在主索引中搜索以获得其他必需的列值。在查询执行计划中，每个索引搜索都显示为嵌套迭代。在嵌套迭代中，左侧节点提供外层循环的输入，外层循环遍历左侧节点的输入数据。将左侧节点的字段值绑定为右侧节点的输入参数，查询执行计划中数据从叶子节点流向根节点的一个例外是**绑定相关参数**，这是嵌套迭代实现（尤其是并行查询执行）的主要困难之一[42]。对于每个不同的参数绑定，执行一次右侧的子计划。 嵌套迭代操作中的内层循环遍历其右侧输入的结果集。

图5.6中的每个实例，右侧子计划是个单节点，即索引搜索。 第一个（最底层的）嵌套迭代搜索课程*biology 101*和其必需的课程属性，特别是==<u>课程编号</u>==；嵌套迭代和索引搜索的其余四个实例使用非覆盖二级索引实现三表连接。图5.6显示了最坏的情况：**学生表**在其主键`student-identifier`上可能有一个主索引，减少一个关联操作，并且**注册表**可能有 50% 的概率在`course-number`上有一个主索引，因为表的主键由两个外键构成。

为了在更多的查询中使用**index-only检索**，某些系统允许在索引定义中添加不属于**搜索键**的列。由**index-only检索**而获得的性能提升必须与额外的存储空间、扫描期间的带宽需求以及数据更新的开销相平衡。主键和外键似乎是最有希望添加的列，因为它们往往在聚合和多表联接的查询中大量使用，并且数据类型的长度较少（例如是整数而非字符串），又很稳定（很少更新）。在**BI**的数据库中，向索引中添加日期列可能也很有用，因为时间在**BI**中通常必不可少。另一方面出于同样的原因，许多查询都基于日期做选择，因此倾向于在索引中使用日期列作为搜索键而不是添加的列。

> ==TODO：==图5.7

与图5.6数据库相同的查询，在有**覆盖索引**（在每个二级索引中添加==冗余的==列）的情况下，**图5.7**显示了其查询执行计划的改进效果。注册表的二级索引包含了`student-identifier`，`student-identifier`的索引中添加了学生姓名，这是最佳的执行计划。

对于给定的查询，如果没有单个索引可以覆盖所有的列，但多个二级索引在一起可能的话，那么在公共引用列上关联两个或多个此类索引，可以将查询所需要的列组合出来。如果二级索引中的记录大小总和小于主索引中的记录大小，则通过关联多个二级索引减少了I/O数量。如果连接算法可以像扫描一样快地消费记录，例如hash join（在内存中，无溢出），则该技术比扫描主索引需要更少的I/O，代价是大量的内存要求。如果查询谓词可以==在一个或多个二级索引中==减少扫描，这种情况尤其可能[52]。

> ==TODO：==图5.8

图5.8显示了查询执行计划的一个片段，其中同一个表的两个索引一起满足了一个查询。现在查询是:

```SQL 
select Title, Instructor from Course where Title like ‘biology*’
```

该计划利用两个二级索引，任何一个索引都不包含查询所需的所有列。**关联谓词**关联两个引用列。 由于两个索引都是按键值排序，而非在引用列上排序，因此**hash join**是最快的关联方法，特别是两个索引扫描的输出结果集有非常不同的数据量，这是因为（两个索引扫描的）谓词可能不一样，或者索引上保留的列数据量不一样[52]。如果要多个索引才能满足查询，所有这些索引都在参考列上关联，则在**基于排序的关联**算法[115]和**基于哈希的关联算法的==组==**中应用==<u>有趣的排序</u>== [52]。

如果多个索引具有相同的排序顺序，则简化的**merge join**就足够了。这是列式数据库的标准技术，其中每列按引用顺序存储；在数据页上压缩甚至省略引用。 在传统的二级索引和列式存储中，可以通过行程编码来压缩重复的列值。

早期的关系数据库管理系统没有利用覆盖索引；相反，它们总是从堆或主索引中获取记录。 当前一些系统仍然这么做。 例如，**Postgres**依赖于多版本并发控制。 由于多版本并发控制的空间开销，例如，所有记录的时间戳，版本控制仅在堆文件中实现，而没有在二级索引中实现。 因此，出于并发控制的目的，任何一个二级索引搜索之后都要再（通过主索引）获取记录。

- 如果二级索引包括查询所需的所有列，则无需访问表的主存储结构（**index-only检索**）。
- 在一些系统中，二级索引可以包括既不是索引键也不是对主索引引用的列。 包含在二级索引中的主要候选者是主键和外键。 其他候选者包括在谓词中经常使用但很少更新的列，例如日期。

### 5.4 索引到索引的导航

如果**index-only检索**不够，有各种技术可以根据从另外索引中提取的值来加快获取B-tree索引中的记录，即，从一个B-tree索引中"导航"到另一个索引，或是从一个索引中一条记录"导航"到另一个索引的另一条记录。这些技术主要是基于两个方法，异步预取和排序。这两种方法可以单独，也可以一起使用，且存在许多许多变体。

异步预取技术可以应用于B-tree中的所有节点，包括叶节点，或是只应用于内部节点。比如执行**索引嵌套循环连接**之前，预先将B-tree的内部节点读入缓存，内部节点通常只占B-tree的1%，这比数据库服务器中，内存和磁盘典型的容量比2-3%要少。页面可以固定在缓存中，以防替换，或者根据标准缓冲池替换策略（如LRU）保留或替换页面。小表及其索引，例如带有星型模式[77]的关系数据仓库中的维度表，甚至可以像产品Red Brick[33]那样映射到虚拟内存。这样，就可以通过内存地址来访问这些页面，而不需要通过页标志符在缓存中搜索它们。

异步预取可以减少等待叶节点的时间。有些系统会填充一个小的、不完整的搜索数组，并一次一批地将它们传递给存储层[35]；另外一些系统始终向存储层通知固定数量的不完整搜索[34]。如果大多数，甚至所有的预取提示都导致缓存命中，为了避免处理无效提示的开销，最好抑制进一步的提示。

除了异步预取之外，通常还需要对中间搜索信息进行排序，即按B-tree的排序规则排序搜索键。 极端情况下，它可以合并同一叶节点的预取请求。多数情况下，对未解析的引用进行排序使存储层能够将许多小的读取操作转换为更少，更大，从而更有效的读取操作。

> ==TODO：==图5.9

图5.9说明了如何预处理一个索引（通常是二级索引）中获取的引用，然后再在另一个索引（通常是主索引）中解析该引用。图5.9中查询计划的中间结果集是一组引用，这些数值可能是主键中的键值。采用最方便有效的方法从二级索引中获取引用值，没有特定的排序顺序来帮助下一个处理步骤。可以使用任何常用的算法和==性能技术==来排序这些引用。压缩可能会降低精度，比如，当把前面三个引用压缩为一个范围时，就丢失了具体信息，因而会读取该范围内的所有记录，并重复进行谓词计算。实现中，排序和压缩可以以各种方式交错进行，这非常像外部归并排序，将消除重复集成到**初始归并段生成**和**归并**的过程之中[16,39]。

在B-tree中可以高效地查找一组有序搜索键，最重要的是，每个节点只需要访问一次，叶节点的持续时间短，分支节点的持续时间较长。一旦搜索完节点，开始搜索其邻居节点后，就可以在缓存中丢弃之；不需要使用像LRU这样的启发式替换策略来保留它们，这样B-tree每层只需缓存一个节点，再适当缓存一些提前读取的节点。考虑到大多数B-tree扇出大，高度小，因此将当前根到叶路径上的所有页面固定在缓冲池中是合理的。此外，如果缓存了每层B-tree节点当前读取的最大键值（通常与B-tree时打开”以供查询执行计划访问时创建的数据结构在一起），则不需要每个单独的搜索从根页面开始。相反，每个搜索都可以尝试按叶到根的顺序搜索B-tree。每个页面最新更新的信息，如ARIES日志序列号[95]，可以确保并发更新不会干扰有效的B-tree检索。B-tree节点中的隔离键（fence key）[44]可以确保范围比较是准确的。Cheng等人[25]描述了一种更通用的技术，利用了磁盘页的父指针，而不是固定在缓冲池中的未排序搜索键序列。

> ==TODO：==图5.10

图5.10展示了图2.4中的部分B-tree和缓存的信息，这些信息使得B-tree在下一次搜索中更加高效。图5.10右边是缓存的数据页，左边是和扫描或查询操作相关的状态信息。如果上一次的搜索键值17，缓存的状态信息包含：指向缓存中三个数据节点的指针、当前层已知的最大键值和每页的PageLSN（日志序列号）。如果接下来搜索键值19，则缓存立即有用，直接从当前叶节点开始搜索。如果接下来搜索键值47，则必须丢弃当前叶节点，但其直接父节点仍然有用，父节点最大的键值是89，这来至于根节点的分隔键。如果接下来搜索键值99，那么就要丢弃叶节点和其父节点，只有缓存的根节点有用。B-tree每层只需要比较一次，就可以为每次查询找到其最佳的开始层次。

如果修改B-tree导致需要回收B-tree节点，则存在一些困难。比如上图的叶节点，由于删除导致节点下溢，将其归并到相邻的叶节点，务必确保搜索不依赖于缓存中的无效页。有多种方法可以解决这个问题，例如验证根到叶路径上所有页面的日志序列号。

为了启用这些优化方法，在查找B-tree之前可能需要显式排序搜索键。有三种方法可以避免在排序过程中产生昂贵的临时文件。第一个方法是分配大内存。第二个方法是只生成初始归并段，因此查询执行时，搜索键部分有序。这可能被称为投机取巧型排序，伺机利用现成的内存尽可能多地输出有序搜索键。

第三个方法使用位图压缩和排序。只有在搜索参数和位图中的位置之间有足够稠密的双向映射时，这个方法才有效。此外，这个映射必须保序，这样扫描位图才能产生有序的搜索键。最后，这适用于从一个表的二级索引跳转到主索引去搜索， 但如果必须在查询执行计划中保存和传播在早期查询操作中获得的任何信息，这个方法就无效了。

图5.11使用位图继续图5.9。为了简便起见，图中使用的是16进制编码，以0x开头表示每块四位数字或16位。考虑到位图通常包含许多0，使用行程编码压缩相似的字节是标准技术，至少可以压缩字节都为0的位图。最后压缩比最大、最简洁的无损表示法交叉使用行程编码、显示位图和显示的值列表。此外为了避免外部排序，该表示法在没有信息丢失的情况下交叉使用压缩技术。

> 看起来像`RoaringBitmap`

> ==TODO：==图5.11

可以组合各种压缩方法。目标是减少大小，以便在内存中保留和排序整个引用集，而无需花费巨大，去访问底层存储设备。如果压缩导致丢某些键值区间的信息丢失，则访问B-tree时，需要扫描整个区间中所有B-tree记录，包括重新计算适当的查询谓词。换句话说，在受影响的键值范围内，重复的B-tree搜索变成了区间扫描。图5.9展示了一个例子。如果分布倾斜是问题，（通常用于查询优化的）直方图有助于选择最有效的搜索键用于压缩。如果在查询执行计划中除了引用之外还必须携带信息，即如果访问索引的目的是满足给定的查询，那么只有无损压缩技术才适用。

排序搜索键不但提高了查询执行性能[30, 96]，还提提高了执行的稳定性[52]。如果查询优化期间的基数估计非常不准确，甚至有好几个数量级的误差，那么排序搜索键为单个排序流并优化B-tree导航，确保index-to-index的查询执行不会比表扫描或是索引扫描差。

> ==TODO：==图5.12

图5.12展示了两个已经在图5.5中展示过的传统执行计划，再加上一个“稳健”的执行计划。对于小查询结果集，从二级索引中获取引用并排序，几乎没有什么额外的执行开销。对于大查询结果集，排序确保查询执行开销不会超过表扫描太多，这里主要差别是因为要从二级索引中获取引用并排序。扫描二级索引和扫描主索引之间的开销之比，与二级索引和主索引记录大小之比相同。利用恰当的压缩技术确保只使用内部排序，避免在整体的查询执行开销中引入太多的IO操作。

这样，图5.12显示了一个健壮的**index-to-index导航**的典型例子。类似的技术并不是只适用于在一张表的多个索引中相互导航，同样也适用于关联多张表的复杂查询。

如果二级索引用于提供一种“有趣的排序”[115]，比如对于随后的**归并联接**，并且如果二级索引不是表和查询的覆盖索引，则归并联接必须在提取完整记录之前发生；或者获取记录的操作不能排序引用，因此放弃高效的检索；或者提取的记录必须按照从二级索引中获得的顺序进行排序。后一种方法实质上要求再做一次排序。

加速第二次排序的一个思路是在第一次排序之前，为每一条记录标记一个序列号，这样第二次排序会比较有效率，且独立于原始二级索引的数据类型和校对序列等。另一方面，联接之前的这次排序需要管理更大的记录尺寸，因此无法从压缩中获益，特别是无法从有损压缩中获益。这样，即使第一次排序操作是内部排序，第二次排序操作则可能是外部排序。

> ==TODO：==图5.13

图5.13显示了查询执行计划的一个片段，在该查询计划中使用这种技术可能是有益的。二级索引提供有序的记录，对于随后像归并联接（图5.13中未显示）这样的操作很有“吸引力”，然而为了能在主索引中可靠检索，需要另一种排序顺序。通过合适的技术，如利用二级索引中的排序顺序，可以提高最终排序的性能。

为了支持多表之间的**index-to-index导航**，一种有前途的启发式方法是在所有二级索引中包括所有键列，包括主键列和外键列。 图5.6和5.7中的查询执行计划之间的差异说明了获益的效果。基于功能依赖性和外键约束，==在二级索引上==包含其它表的列可以扩展该技术。例如，订单明细表日期列上的索引可能包含客户标识符，订单明细表则通常不包括此列，因此对订单表存在适当的功能依赖性。

- 如果需要在索引中探测大量的搜索键，排序可以避免重复地搜索，提高缓存的有效性，并因此减少IO的开销。
- 索引搜索可以在先前搜索停止的地方恢复，从而在B-tree索引中引发向上或向下导航。
- 这些优化实现了稳健的查询执行计划，从基于二级索引仅提取少量数据到完整扫描主索引，从而降低了由于编译时查询优化器错误地估计基数而导致令人惊讶的性能。
- The break-even point between optimized scans (e.g., in compressed column stores) and optimized index retrieval may shift with the transition from traditional high-latency disk storage to semiconductor storage such as flash.






