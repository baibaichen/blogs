## 5. 查询处理

B-tree索引只有用到才有价值，这需要查询优化器考虑到使用它们的查询执行计划，查询执行时真正利用它们。**因此，本节总结了通常与B-tree索引结合使用的查询执行技术**。在进入各个小节==讲解==使用B-tree的查询处理技术之前，先简要介绍查询处理及其两个主要组件：查询优化和查询执行。自动优化查询的需求和机会来自于使用非过程性数据库语言（如SQL）的用户接口和物理数据独立性。

术语**物理数据独立性**描述了逻辑数据（表和物化视图）与物理数据（堆文件和索引）的分离。**表**包含**由名称标识的列**和**由唯一主键标识的行**，行包含列值。文件和索引包含由堆中的**记录标识符**或索引中的**唯一搜索键**标识的记录，记录包含字段。当然，行和记录之间、列和字段之间存在关系，但物理数据独立性使得这种关系相当松散。

> ==TODO：==，图5.1

利用这些松散关系可产生许多优化机会。在上面使用的术语中，表和索引之间、逻辑行和物理记录之间可能存在多对多关系。有趣的是，数据库对象之间的实体关系建模类似于用户数据库的实体关系建模，并且可以使用标准技术导出所需的元数据表。当然，不仅逻辑数据库设计，物理数据库设计也适用于目录表，包括在内存缓存中放置目录信息的数据。

> 1. 原文这里的**schema concepts**翻译成**数据库对象**，schema本来就有数据库的意思，在MySQL中`create schema`等同于`create database`。
>
> 2. **entities and relationships**，就是ER数据模型

图5.1显示了表和索引这两个实体类型，及它们的属性：列和索引字段。在大多数数据库管理系统中，表和索引之间是一对多关系，即一个表可以有多个索引，但一个索引只能属于一个表。多对多关系表示支持**联接索引**[123]。索引和B-tree之间可以是一个简单的一对一关系，不需要在ER图中进一步详细说明；如果每个索引可以划分为多个B-tree，则为一对多关系；或者，如果是==**主从聚集**==，则是多对一关系，例如**合并B-tree**[49]。

根据软件系统提供的功能，**数据库的物理设计**可能仅限于索引调整，也可能利用水平和垂直分区，面向行或列的存储格式，压缩和位图编码，页面和索引中的空闲空间，排序顺序和主从聚集，以及许多其他选项[38]。考虑到自动化的趋势，在**数据库的物理设计**中，似乎也应包括自动化，例如，自动创建和维护统计信息（直方图）和软约束[60]、自动创建和优化索引、以及自动创建具有自己的索引，统计信息和软约束的物化视图。

由于数据库查询指定表，但查询执行计划访问索引，因此需要映射。物理数据独立性允许并要求在此映射中进行*选择*。查询优化是资源密集型的，传统的数据库分为**编译时查询优化**和**运行时查询执行**。除了访问路径选择，查询优化还选择执行算法（例如hash join或merge join）以及处理顺序（例如join顺序）。

这些*选择*在查询执行计划中==捕获==。 **查询执行计划**通常是棵树，但在**公共子表达式**的情况下，它可能是DAG（有向非循环图）。请注意，在查询优化期间可能会引入**公共子表达式**，例如，包括`distinct`关键字、含有多个聚合的查询，具有垂直或水平分区的表，以及大规模更新。

> ==TODO：==，图5.2

图5.2显示了一个简单的查询执行计划，数据结构由查询优化器在编译时构建，并由查询执行引擎在运行时解释执行。节点指定算法和所需的表达式，例如**谓词**、**排序子句**和**投影列表**。理想情况下将其编译成机器码，但在今天，编译成特殊用途的字节代码，然后在运行时解释执行似乎更为常见。

在大多数查询引擎的执行计划中，**控制流从消费者流向生产者，数据流从生产者流向消费者**。数据流单元可以是一条记录、一个“值包”[78]、一页，或任何其他被认为是在复杂性和性能之间良好折衷的数据单元。执行树中的控制流通常通过迭代器[39]来实现，从而产生自顶向下的控制流。一个例外是查询执行计划里有多个消费者共享的（公共）子计划，且需要嵌套迭代。这是由于复杂性或是存在索引（因而更加高效），所以查询优化器没有“展开”**嵌套SQL表达式**。如果查询执行在管道中使用多个线程，则自下而上控制通常似乎更合乎需要。管道中生产者和消费者之间的==流量控制==实际上使得它们没有区别。自下而上的线程启动似乎与自上而下的迭代器相矛盾，但事实上并非如此[40]。

<u>一些操作，最明显的是排序，输入和输出不重叠，许多情况下还存在中间步骤。这些算子的步骤描绘了计划阶段，例如，从一个**排序算子**（在其输出阶段）到**归并连接算子**，再到另一个**排序算子**（在其输入阶段）中的管道</u> 。称这些算子为“走走停停”算法，管道破坏器和其它类似的名称，它们在查询执行计划中出现显然会影响资源管理，如内存分配。

> ==TODO：==，图5.3

<u>图5.3将计划阶段添加到图5.2的查询执行计划中，这是因为排序是“走走停停”算子</u>。中间的计划阶段可选：如果输入大小和排序用到的内存使得仅需要单步合并，则可省略中间阶段。

大多数传统系统执行查询计划非常严格：查询优化器进行选择，查询执行引擎遵循这些选择。但查询执行期间也存在多种选择，从资源管理（例如，排序和hash join的工作空间大小）到执行计划的有限修改[84]，以及记录的自由路由[3]。运行时验证查询优化器采用的假设和估计，例如中间结果中的记录数和数据分布，使得查询执行期间进行选择受益。

区分B-tree索引与其他索引的一个特点是它支持有序检索。 索引项有序支持**范围谓词**和**多列索引中的多个谓词**。 中间查询结果的排序有助于索引到索引的导航、磁盘检索、集合操作（例如索引交集）、merge join、基于顺序的聚合和嵌套迭代。

- 因为描述式（非过程）的查询语言和物理数据独立性，查询优化器在编译时选择查询执行计划，即由查询执行算子组成数据流图。优化器选择执行计划是基于基数估计，以及不同查询表达式和执行计划的执行成本。
- 在查询执行计划中利用B-tree索引来检索（例如，查询文本中的文字查找）和有序扫描。
- 查询优化也可以提高索引更新（索引维护）的性能。

### 5.1 磁盘扫描











