## 3-数据结构和算法

本节关注的是在成熟的数据管理系统中用到的数据结构和算法，它们通常不会出现在大学水平的教科书中。随后的小节将会讨论事物处理技术、如何在数据库查询处理中使用B-trees、以及B-tree的实用工具。

虽然仅有一个小子章节命名为“数据压缩”，但几乎所有的子章节在某种形式上都从属于压缩：使用更少的字节存储记录、多条记录整合在一起描述、每次搜索较少的字节、每次更新修改较少的字节、以及避免碎片和空间浪费。本节的主题是空间和时间上的性能。

后面内容按这样组织：第一组关于节点的尺寸和内部结构、接下来一组和特定的压缩技术有关、最后一组是空闲空间的管理。大多数子章节讨论的技术都相互独立，当然，某些技术组合起来可以减少实现难度。==**比如**除非键值被转换成二进制字符串，否则前缀和后缀截取需要为每条记录保留详细，或过度的信息==。

### 3.1 节点尺寸

实际上关于B-trees最早的论文就讨论过B-tree在磁盘上的最佳节点尺寸[7]。主要是取决于访问延迟、传输带宽和记录尺寸。高延迟和高带宽都导致要使用更大的尺寸，所以，现代磁盘上最佳的节点尺寸接近于1M，但在闪存设备上最佳的节点尺寸仅是几KB[50]。通过让访问延迟和传输时间相等来计算节点尺寸是一种有效的启发式方法（访问延迟乘以传输带宽）–它至少保证了维持一半的最优理论带宽和最优理论IOPS。例如，对于5ms访问延迟的磁盘，200M/s的传输带宽，节点尺寸将是1M。预计0.1ms的访问延迟和100MB/s的带宽的闪存设备，有效的B-tree节点尺寸是10KB。

更精确的优化目标是每单位的I/O时间内，比较次数最多。在原始的论文[7]中就可以找到这种计算的例子。这种优化假定，优化目标是根到叶的点查询，而非大区间查询；I/O是瓶颈，而非CPU；节点内使用二叉搜索；以及根到叶的查询中的总比较次数与节点尺寸无关（前面已讨论过）。

> ==TODO：==Fig 3.1

图3.1显示的是和[57]类似计算的结果。通常对于非聚集索引，可以假设每条记录大约20字节，每页大约填充了70%的空间。因此，4KB的页大约每页有143条记录，平均来说需要7次比较。就搜索而言，我们把比较的次数称之为节点的效用。假定5ms的访问延迟，和200MB/s的突发带宽，我们推算出图11中的I/O时间。上面启发式的方法建议采用1000KB的节点（5ms ×200MB/s）。不过，128KB的B-tree节点使二叉搜索中的比较次数于磁盘的I/O时间之间的比值最大。历史上常见的4KB磁盘页远远小于传统磁盘上B-trees索引页的最佳尺寸。对于B-tree索引，不同的记录尺寸和不同的设备有不同的最佳节点尺寸。最重要的是，相比于磁盘设备，基于闪存的设备可以获得100倍的访问频率，但不会大幅度的影响传输带宽，因此，最佳的B-tree节点尺寸相当小，例如，2KB[50]

- The node size should be optimized based on latency and bandwidth of the underlying storage. For example, the opti-mal page size differs for traditional disks and semiconductor storage.

### 3.2 插值搜索

和二叉搜索类似，插值搜索也是利用搜索余下的空间（剩余空间一开始是整个页面）。不过，二叉搜索是检查剩余空区间中点的键值，而插值搜索则是估算查找键值的位置，查找位置通常是根据剩余空区间中最小和最大的键值，经由线性插值而得。对于某些键值，比如由顺序过程产生的人工标识值，插值搜索相当高效，像企业经营活动中的发票号码就是这样的例子。==事实上，插值搜索是赢得事务处理性能基准测试的必备技术之一==。

**最好的情况**，插值搜索几乎是无敌的。考虑订单表中订单号这列上的索引，考虑到订单号总是顺序分配的，由于每个订单号总是只分配一次，在B-tree节点中成百上千个记录里进行插值搜索，马上就能找到正确的记录。

**最坏的情况**，由于键值分布不均匀，纯插值搜索和线性搜索性能一样。插值搜索理论复杂度是`O(loglogN)`  [36,107]，在实际使用的页尺寸中，大约是2到4次比较。这样，如果3到4次比较后还未找到查找的键值，那么键值的实际分布不均匀，最好是在剩余的区间中使用二叉搜索。

**相比于在插值搜索和二叉搜索之间进行简单切换，两者间逐渐转换可能会取得更好的效果。**如果插值搜索未将查找直接引向搜索的键值，而是引向剩余区间的一端，那么用于二叉搜索的剩余空间可能很大，也可能很小。因此，看来明智的方法是在前一步就进行转换，这样搜索键值在较小剩余空间的可能性将会非常大。

初始的插值计算可以使用页面内可能最小和最大的键值、或是页面内实际上最小和最大的键值、或是基于当前所有键值的样本回归线。最后一个技术可通过相关系数增强，相关系数在初始几步就能引导查找是迈向插值还是二叉搜索。样本和与样本数用于快速推导样本回归线和相关系数，当页面内单个记录更新时，就能对它们进行增量维护。

> ==TODO：==Fig 3.2

图3.2展示了两个B/-tree节点及其键值。在上面的节点的中，插槽和键值的相关系数相当高（>0.998）。斜率和截距分别是3.1和5.9（插槽从0开始计数）。使用插值搜索查找键值12，使用公式(12− 5.9)÷3.1= 2（取整），可以马上算出插槽的位置，确实可以在这找到键值12。换句话说，如果位置和键值之间的相关系数非常强，插值搜索很有效。在图3.2下面的节点的中，斜率和截距分别是-64和31，更重要的是相关系数很小(< 0.75)，使用插值搜索查找键值97，一开始探测的第5个插槽（(97− -64) ÷31=5），而非正确的第8个插槽。所以，如果位置和键值之间的相关系数很弱，二叉搜索更有效。

> 注：`y=k*x + b`，k称之为斜率(slope)，b称之为截距(intercept)，y就是键值，x是键值对应的插槽位置。插值搜索实际上就是：#1预先在更新时，通过对键值和位置做线性回归算出斜率和截距；#2查找时，通过键值、斜率和截距估算出x，当然也可按最小和最大值来推算。如果键值分布均匀，插值搜索很有效，不过对于字符串类型不知如何处理

- If the key value distribution within a page is close to uniform, interpolation search requires fewer comparisons and incurs fewer cache faults than binary search. Artificial identifiers such as order numbers are ideal cases for interpolation search. 
- For cases on non-uniform key value distributions, various techniques can prevent repeated erroneous interpolation. 

### 3.3 变长记录

虽然，我们常用固定长度的记录（包括中间节点中的分隔键和页节点中的数据记录）来讲解B-tree，但实际上，所有的数据库系统都需在B-tree中支持可变长度的数据记录和分割键记录，这样B-tree的空间管理就不是那么简单了。

在B-trees和堆文件固定长度的页中支持变长记录的标准设计是：**间接数组**（也被称之为插槽数组）。间接数组中的每一个指针记录大小都相等，并代表一条数据记录，其必须包含数据记录的偏移地址，也可以包含一些额外的信息，例如，数据记录的长度。

图3.3展示了数据库里磁盘页中最重要的部分。磁盘页的最左边是页头，包含了页的标志符、B-tree的页层次（用于一致性检查）、记录数，等等。在图3.3中紧随其后的是间接数组。在堆文件中，记录删除后，对应的插槽仍保留为未用，这是为了确保剩下的数据记录仍能保留它们的标识符。在B-tree中，插入和删除记录后需要移到一些插槽，这是为了确保二叉搜索可以正确工作。4.2小节的图4.7展示了另一种方案，相比于传统的设计，由于在数据记录中故意留有空隙，因此只需更少的移动。每一个有效的插槽都包含了一个指向数据记录的指针（表现形式为页内的字节偏移量）。**在下图中，间接数组从左向右增长，记录集合从右向左增长，反过来也是可行的。让这两个数据结构相对着增长，即能保证存储许多小记录，也能保证存储少量大记录**。

> ==TODO：==Fig 3.3

为了能高效地进行二叉搜索，间接数组中的指针记录按其搜索键值有序排列，但没有要求其按数据记录的偏移位置排序，也就是数据记录放置的位置。比如，图3.3中左边的插槽序列没有按右边的数据记录位置排序。按数据记录位置排序只是临时需要，比如为了一致性检查、压缩或合并空闲空间。这些操作可能会在记录插入、更新（记录长度改变）、或是碎片整理中调用。

记录插入要能为间接数组中的指针记录和数据记录都能找到空闲空间。在标准的设计中，间接数组从页内的一端向另一端曾长，被数据记录占用的数据空间则按反方向增长。对于插入的记录，通常在中间的空闲空间内增长数据空间就能很快为其找到所需的空间。对于在间接数组中插入的指针记录，需要在间接数组中找到正确的放置位置，并要做相应的移动，平均来说，间接数组中一半的指针记录必须移动一个位置。

记录删除非常快，因为删除通常只是在数据空间中留下一个空白。但是，必须保持间接数组稠密且有序，因此会向插入那样移动指针记录。在近来的一些设计中，减少了移动次数[12]。有些设计为了在中间节点中获得有效压缩，以及高效的搜索，因而也会在中间节点中将分隔键和子节点指针分开来存储。这些技术也会在随后讨论。

- 通过页面内的间接层可以有效地支持变长记录。
- 间接数组中的移动操作可以通过间隙（无效记录）最小化。

### 3.4 键值规范化

为了减少比较的开销，很多B-trees的实现会将键值转换成**二进制字符串**，这样简单的二进制比较就能满足创建索引所需的记录排序，以及引导B-tree的搜索找到正确的记录。原始键值和二进制字符串的排序顺序一样，因此所有的比较都等价。二进制字符可以编码很多信息：多列、列的排序方向（比如降序）、以及排序规则，这包含本地的字符串（如大小写不敏感的德语字符），字符串的长度或是终止符等等。

键值规范化是一个历史很悠久的技术。1969年，Singleton[118]就曾提及该技术，但并没有引用其出处，推测起来，要么这个技术相当有名，要么就是微不足道：“整数比较用于对规范化浮点数排序”。

> ==TODO：==Fig 3.4

图3.4说明了这个想法。第一位（图中带下划线）表明主要键值列是否包含有效键值。用0表示**null**值，而用1表示其它键值，这确保了**null**值小于其余所有键值。如果列值非**null**，那么键值将会存储在紧跟其后的32位中。就像针对浮点值，需要正确处理指数、小数部分和两个符号位一样，为了确保正确的顺序，符号整数也需要倒转一些bits。后续的单个bit（也用下划线标出）表明第二列是否包含有效键值，这里是用文本字符显示，但实际上应该存储为针对比较规则编码的二进制值。字符串的终止符（显示为\0）标记了字符串的结束位置，终止符必须能确保正确的排序顺序，例如，使用简单的二进制比较算法，长度指示位将会破坏规范化键值的主要价值[==就是说，字符串的比较方法，a和ab要小于b，采用二进制的比较法，ab也要小于b，所以如果同时存储了字符串的长度，很难保证ab<b==]。如果字符串终止符有可能作为合法的字符出现，那么二进制的表示法必须使用另一个没有包含在编码表中的终止符。注意图中第二列表示null值（第三行）和空值（第四行）的区别。

某些比较规则，会让规范化键值丢失信息。一个典型的例子就是对有大小写区分的语言，做大小写不敏感的排序，并创建相应的索引。这样，两个不同的原始字符串可能会映射为一样的规范化键值，不可能从规范化键值反推出原始的键值。搞定这种问题一个方法是两种键值都存储。第二个方法是在规范化键值中追加最少的信息，确保其能准确恢复出原始的键值。第三个则是B-tree索引特有的方法，注意到内部节点并不包含用户数据，其中的键值只不过是用于引导搜索到达正确的字节点，所以只在内部节点使用规范化键值。

[许多操作系统都提供了恰当的函数](http://msdn.microsoft.com/en-us/library/dd319092(VS.85).aspx)，用以将本地化的字符串、日期或时间转换成规范化键值。比如，这些函数会用于正确地排列目录中的文件（文件名是本地化字符串）。增加对数字类型的支持则相当直接，类似于多个规范化值连在一起。但是由于操作系统的更新频率，数据库索引并不能依赖于操作系统的这个功能，操作系统可能会因为修复BUG、增加功能、扩展本地化的排序顺序定义而引入变化，如果此种变化使得已经存在的大量数据库索引不正确，这是不可接受的。

规范化键值的另一个问题是和原始字符串相比，它们更容易产生较长的键值，特别是某些国家的语言，针对顺序、排序和索引查找有复杂的规则。因此看起来压缩规范化键值是相当合理的技术，但似乎在著作里还没对其有详细的描述。所以，规范化键值主要是用在内部节点中，这是因为可以简化前缀和后缀截取的实现，但又无需恢复原始键值。

- Normalized keys enable comparisons by traditional hardware instructions, much faster than column-by-column interpola-tion of metadata about international sort order, ascending versus descending sort order, etc. 
- Normalized keys can be longer than a traditional represen-tation but are amenable to compression. 
- Some systems employ normalized keys in branch nodes but not in leaf nodes. 

### 3.5 前缀B-tree

一旦将键值转换成简单的二进制字符串，就更容易实现B-tree的另一项优化技术：即**前缀**和**后缀截取**，或压缩[10]。没有键值规范化，即使是截取键值字段，而非单独的字节，也需要相当多的薄记工作；==<u>键值规范化之后，根据规范化键值中的特定字节，自然就会用到这些技术</u>==。

前缀截取将会分析B-tree节点中的键值，提取节点中全体键值的公共前缀，公共前缀仅需在节点中存储一次。节省存储空间会提高叶节点记录数，也能提高内部节点扇出。此外，搜索时无须比较截取的字节。

> ==TODO：==Fig 3.5

图3.5显示了同样的记录是如何在有前缀截取和没有前缀截取的B-tree节点中存储的。显然，后一种存储方法效率更高。也可以把前缀截取和其它的一些压缩技术组合在一起，比如，从上图的生日中消除反斜杠符号。当然了，总是要在实现复杂度、测试开销、运行性能和存储效率之间做平衡。

可以从节点内的全体键值中提取公共前缀，也可以从部分键值中提取，但从代码简洁性的角度看，每个节点有一个统一前缀较好。此外，前缀截取可以基于当前节点内实际持有的键值；也可基于自节点创建之时的键值；还可基于由父节点、祖父节点中分隔键所确定的某个合理的键值区间，但从代码简洁性的角度看，特别是插入时的代码简洁性，即使基于当前节点内实际持有的键值进行前缀截取有更好的压缩效果[87]，仍是基于最大可能的键值区间进行前缀截取较好。如果前缀截取基于实际的键值，插入一个新的键值可能会强制重新分配所有已有的键值。极端情况下，新的记录可能远小于B-tree页内空闲空间，但仍需强制进行页分裂。

为了维护B-tree页内最大可能的键值区间，可在每个节点内保持两个栅栏键，即节点分裂时，在其父节点内保存的分隔键的一份拷贝。图4.11（4.4节）说明了B-tree索引内多个节点中的栅栏键。在B-tree中实现栅栏键有很多好处，比如，有利于键值区间封锁。对于前缀截取，页内两个栅栏键共享的前导字节就能确定页内当前所有以及后续的键值。同时，前缀截取减少了栅栏键带来的开销，后缀截取可以确保分隔键，也就是栅栏键尽可能的小。

前缀截取可以和插值搜索相互配合。如果针对固定大小、有限精度、删除公共前缀后的键值进行插值计算，尤其可以确保插值更加准确。所以，规范化键、前缀截取和插值搜索在具体实现时多半会组合在一起。

前缀截取的另一个技术是偏移值编码[28]，用于高性能排序，尤其是用在排序段和合并逻辑中[72]。在这种表示法中，每个字符串将会与排序序列中其直接前驱比较，用共享前缀的长度替换之，可以节省更多的空间。The sign bit is reserved to make the indicator order-preserving, i.e., a short shared prefix sorts later than a long shared prefix. The result is combined with the data at this offset such that a single machine instruction can compare both offset and value. This representation saves more space than prefix truncation applied uniformly to an entire page. 非常适用于顺序扫描和归并，但并不适用于二叉搜索或插值搜索。尝试结合二叉搜索和此种方法优点的一种方案是**单词查找树**，不过很少用在数据库系统中，原因可能是代码复杂度和更新开销。

> A very different approach to prefix truncation technique is offset-value coding [28]. It is used in high-performance implementations of sorting, in particular in sorted runs and in the merge logic [72]. In this representation, each string is compared to its immediate predecessor in the sorted sequence and the shared prefix is replaced by an indication of its length. ==The sign bit is reserved to make the indicator order-preserving, i.e., a short shared prefix sorts later than a long shared prefix. The result is combined with the data at this offset such that a single machine instruction can compare both offset and value. This representation saves more space than prefix truncation applied uniformly to an entire page.== It is very suitable to sequential scans and merging but not to binary search or interpolation search. Instead, a trie representation could attempt to combine the advantages of prefix truncation and binary search, but it is used in very few database systems. The probable reasons are code complexity and update overhead.

即使并未在B-tree页内使用前缀截取，也可利用其快速比较的特点，获得更快的搜索。这个技术可以称之为动态前缀截取。在父节点中查找子节点指针时，将会检查子节点指针两侧的键值，如果这两个键值共享一些前缀，那么该指针指向的子节点^a^上的***Key***必含有同样的前缀，在后续的比较中就可以忽略（这些前缀）。并不一定要比较父节点中彼此相邻的两个分隔键，所需要的（前缀）信息可在查找的键值与分隔键值相比时获得。换句话说，在B-tree根到叶的搜索中，可以利用动态前缀截断，而无需增加比较步骤。

> a. 其实是子树

例如，在图3.5左边的B-tree节点中进行二叉搜索，如果剩下的搜索区间是从“Smith,Jack”到“Smith,Jason”，由于查找的键值肯定在该区间，因此必以“Smith,Ja”开始，==<u>所以在该搜索剩下的所有比较中可略过这个前缀（可假定该前缀一定存在）</u>==。注意，动态前缀截取也可应用在保存了公共前缀的B-tree节点内，在这个例子中，除了公共前缀“Smith,J”可以跳过外，在余下的搜索中还可跳过字符串“a”。

**前缀截取**可以用在B-tree所有的节点中，后缀截取则尤其适合于内部节点中的分隔键[10]。前缀截取在叶节点中最有效，后缀截取主要影响内部节点和根节点。当把叶节点分裂成两个相邻的叶节点时，需要一个新的分隔键。相比于取左边节点的最大键值，或是右边节点的最小键值，分隔键值可以取（在叶节点上）区分这两个键值的最短字符串。

> ==TODO：==Fig 3.6

**例如，假设图3.6中显示的键值处于将要被分裂节点的中部。**长箭头指向的是正中心，如果在这点分裂，那么分隔键需要包含名字的第一个字母，这至少需要9个字母^b^。相反，如果可以在短箭头之间任一点分裂，那么一个字母就够了。在分裂区间两端的键值之间做一次比较，就能决定可能最短的分隔键。例如，图3.6中，将会在“Johnson,Lucy”和“Smith,Eric”间进行一次比较，在第一个字母处就能发现不同，这表明一个字母的分隔键就足够了，只需选择一个比J大、但不大于S的字母即可。并不要求这个字母是真正的键值。

> b. ==英语中，表达姓名时，如果你看到逗号，那是为了特殊需要（例如当时需要按姓排序），把姓放在前面。逗号前是姓，其后是中间名（如果有中间名的话），然后是名(first name == given name)== 

一个诱惑人的方案是：不仅在分裂叶节点时截取后缀，分裂内部节点时也要截取后缀。可惜这个方法有问题，祖父节点中的分隔键不仅要指导搜索到达正确的父节点，还需要指导搜索到达正确的叶节点。换句话说，再次使用后缀截取，可能将搜索指引到左子树最右的节点，而不是右子树最左的节点；或反之。幸运地是，99%的B-tree节点是叶节点，99%剩下的节点是叶节点的直接父节点，额外的截取最多使万分之一（1%中的1%）的节点获益。这样，这个有问题的方法，即使能完美无瑕地运行，对B-tree的深度和搜索性能可能就没什么重大影响。

> ==TODO：==Fig 3.7

图3.7解释了该问题。上方B-tree的分隔键，按缩短的键值“g”分裂得到下方的B-tree，然而部分叶节点并不按“g”分裂。因此，搜索键值“gh”将会被指引到右子树，所以找不到“gh”，显然不对。正确地指引搜索需要基于原始的分隔键“gp”。即分裂内部节点时，无需再截取后缀。分裂内部节点时，只能选用分裂点的键值作为分裂键。例如，分隔键“r”由于其长度较小，看起来似乎更好，可惜，它不能在中心处分裂老的根节点。

- A simple technique for compression, particularly effective in leaf pages, is to identify the prefix shared by all key values and to store the prefix only once.
- Alternatively, or in addition, binary search and interpolation search can ignore key bytes shared by the lower and upper bounds of the remaining search interval. In a root-to-leaf search, such dynamic prefix truncation carries from parent to child.
- Key values in branch pages need not be actual key values. They merely need to guide root-to-leaf searching. When posting a separator key while splitting a leaf page, a good choice is the shortest value that splits near the middle.
- Offset-value coding compares each key value with its immediate neighbor and truncates the shared prefix. It achieves better compression than page-wide prefix truncation but disables efficient binary search and interpolation search. 
- Normalized keys significantly reduce the implementation complexity of prefix and suffix truncation as well as of offset-value coding.

### 3.6 CPU 缓存

在B-tree的页中进行搜索，缓存失效是性能开销的重大部分。If a B-tree needs to be searched with many keys and the sequence of search operations may be modified, temporal locality may be exploited [128]. Otherwise, optimization of data structures is required. Cache faults for instructions can be reduced by use of normalized keys — comparisons of individual fields with international sort order, collation sequence, etc., plus interpretation of schema information, can require a large amount of code whereas two normalized keys can be compared by a single hardware instruction. 此外，规范化键不止是简化了前缀和后缀截取的实现，也简化了访问数据时为减少缓存失效而实施的优化。事实上，许多优化似乎只是在使用规范化键时才有实用性。

> 可以通过使用规范化键来减少指令的缓存失效–在几个独立的字段之间进行比较，由于涉及到排序次序、排序规则等，再加上对结构信息的解释，需要大量的代码，反之用单个硬件指令就能比较两个规范化键[看[这个](http://msdn.microsoft.com/en-us/library/ms143726.aspx)和[这个](http://msdn.microsoft.com/zh-cn/library/ms143726.aspx)]。

截取公共前缀后，只需比较头几个字节，就能搞定二叉搜索中的大多数比较。即使在没有使用规范化键的记录中，例如，B-tree叶节点中的记录，存储规范化键的前几个字节也能加速比较操作。**如果仅仅只是存储了几个字节，而非整个规范化键，可以搞定大多数的比较（但非全部），**这称之为“==<u>最小规范化键</u>==” [41]。

为了在查找和比较数据记录时没有缓存失效，可以在间接数组的元素中附加一个字段用于存储最小规范化键值。这个方法已经成功用于AlphaSort的实现中[101]，在B-tree节点中使用也同样有用[87]。

另一方面，也要保持间接数组中的每一个元素都较小。前面讨论图3.3时提及：传统设计常常会在间接数组的元素中包含数据记录的长度，但是如果不访问记录，几乎就用不到记录长度。这样，指示记录长度的字段无需存放在间接数组元素中，而是和数据记录放在一起。

> ==TODO：==Fig 3.8

图3.8例示了这样的一个B-tree页面，包含三个欧洲国家。左边是页头和间接数组，右边是变长记录。这儿的最小规范化键就是键值的第一个字母，保存在间接数组中，键值剩余的字节和记录长度保存在主记录中。搜索“Denmark”，由于最小规范化键，无须访问主记录，因此不会招致针对主记录的缓存失效。另一方面，搜索“Finland”，二叉搜索仍可以使用最小规范化键，但最终还是必须访问“France”这条主记录。虽然图3.8中的最小规范化键仅由一个字母组成，但是2或4个字节似乎更合适些，不过这取决于页尺寸。例如，由于闪存设备的访问延迟小，其最佳的数据库页尺寸应较小，2字节可能合适些；反之，由于传统的磁盘传输带宽大，其最佳的数据库页尺寸应较大，4字节可能合适些。

==另一种设计方案是将间接数组按缓存行组织成B-tree，而非线性的数组==。这个B-tree的每一个节点的长度要么和缓存行一样长，要么小于它[64]。在这类B-tree根到叶的搜索中，可以使用指针，也可以通过地址计算来找到子节点[110,87]。相比于没有针对CPU缓存优化的节点，这种方法能减少节点内一半的搜索时间和缓存失效[24]。一个互补、更加理论化、更加高效的缓存访问策略，更加复杂，但达到最佳的渐进性能的设计是独立于磁盘页或缓存行长度[11]。B-tree节点的两种组织方式，即图3.8中的线性数组和==**B-tree节点中的B-tree**==，都可以从幻影插槽中获益，幻影插槽是指含有合法的键值但是标记为无效（被删除）的指针记录，后面马上会讨论到^c^。

> c.这段讲了两个技术，一个是缓存感知的B-tree，一个缓存遗忘的B-tree，这就是为什么说互补的原因。截取公共前缀的技术倒是在Berkerly DB有用，~~这段所说的两种技术似乎没什么商业应用，直接忽略。~~  https://github.com/Percona/PerconaFT 

- 缓存失效可能会浪费100多个CPU周期。可以优化B-tree页面以减少缓存失效，就像优化B-tree（与二叉树相比）以减少页面失效一样。

### 3.7 重复的键值

**搜索键中有重复的键值很平常**。重复的记录则不太常见，但在某些数据库中的确存在，即如果关系和表中存在混淆，并且没有定义主键。对于重复的记录，标准的解决方案是要么存储多份拷贝，要么是储一份拷贝再加上一个计数器。前一个方法实现起来要简单一些，后一种方法则需要在查询操作中维护计数器，例如：在求和或是求平均值时要用到乘法、消除重复记录后要将计数器置为1、在**join**两个计数器时要相乘。

经由**二级索引**跳转到**主索引**，或是删除某条记录的B-tree索引时，重复的键值会导致歧义，所以B-tree索引中有重复键值并不是好事。**因此，正如我们前面讨论的那样，B-tree的所有索引都必须唯一。**尽管如此，仍可利用搜索键值前导字段中重复的键值，来减少存储空间，及提高搜索性能。

保存**非唯一键值**及其关联信息最简单的方法，是将每个键值与表示信息的数组结合起来。非唯一二级索引中的传统格式是将**记录标识符**作为**键**的**关联信息**。为了高效搜索，例如在删除时，记录标识符列表保持有序。还可以利用一些简单的压缩方法，一种方案是，只存储相邻值之间的差异，而不是保存完整的记录标识，最小化存储的字节。前面已经讨论了类似的方案作为前缀B-tree的替代方案。为了搞效的顺序搜索，可以调整==<u>偏移值编码</u>==[28]。

这个方法一个更复杂的变体是前缀键值只保存一次，并将剩余的记录存储在数组中。例如，如果前导键字段很大（占用空间多），没有几个不同的值，而最终键字段很小（占用空间少），有很多不同的值，那么这些前导字段的值只存储一次可以节省存储空间。

另外一种表示**非唯一二级索引**的方法是使用**位图**，有多种形式和变体。将在后面讨论。

> ==TODO：==Fig 3.9

图3.9中每行的信息都相同，但表示方法不同：**(a)**重复的键值分别由不同的索引记录表示，每个键值都关联不同的记录标识符。这个简单方案需要的空间最多。**(b)**每个唯一的键值及其对应的记录标识符数组，和**(c)**前面两个方法的组合，适合于分割超长的记录标识符数组，比如记录标识符数组跨越了好几页。**(d)**展示了一个简单的、基于截取共享前缀的压缩算法，**“(9)2”**说明这条索引记录和其前个记录的前九个字符串或 “Smith,471”相同，后面跟随字符串“2”。注意，这与前缀B-tree不同，后者从页面或B-tree节点中的所有记录中截断相同的前缀。**(e)**显示了另一种简单的压缩方案，基于行程编码。编码“**4711(2)**”则表明连续两条记录以4711开始。**(f)**显示可能在位图索引中使用的位图。前面的**4708**表示位图中的第一位对应的整数；位图中为 “1” 的位表示值4711、4712和4723。位图自身通常使用某种行程编码的变体进行压缩。毫无疑问，许多读者可以设计额外的变体和组合。

每个方案都有自身的优缺点。比如(d)看起来结合了(a)的简单性，同时空间效率又和(b)想当，但是无论是使用二叉搜索还是插值搜索，都需特殊的考量才能获得高效的查找。换句话说，没有看起来完美的方案。这可能是由于『压缩算法』主要是关注于『压缩数据结构内』的顺序访问，而非随机访问。

可以为多列（『*Key*由多列组成』）B-tree扩展这些方法。例如，第一字段中每个不同的值可以与的一组值配对，并且第二个字段中的每个值都有一个详细信息列表。一个具体示例，在学生和课程的关系数据库中，**多对多关系的索引**对于第一外键（例如，学生标识符）有许多不同的值，每个都对应一组第二外键的值（例如课程号），和关于==**每对键值关系的**==额外属性（例如，学生选修课程的学期）。信息检索中的全文索引，可能有许多不同的**关键字**，每个**关键字**对应的是一组包含这个**关键字**的**文档**，每个**文档记录**对应一组在该**文档**中该**关键字**出现的位置。忽略压缩，这是许多文本索引的基本格式。

如何“表示”重复键值是一方面，重复键值还牵涉到关系数据库的完整性约束，为了保证**唯一约束**，常利用B-tree来防止插入重复键值。另一个不常用的技术，利用已经存在的B-tree（假设存在合适的B-tree）索引，来快速创建和验证新定义的**唯一约束**。插入新键值时搜索适当的插入位置，可以指示与**未来任何一个邻居键**==<u>共享</u>==**最长的前缀**。这和**动态前缀截取**的逻辑相似。根据这种共享前缀的长度，B-tree索引的元数据可以包括不同值的计数器。在多列B-tree中，可为每列维护一个计数器。一旦声明了唯一约束，这些计数器马上就能判断出是否违反了新声明的唯一约束。

- 即使每个B-tree记录都唯一，键也可以分为前缀和后缀，使得每个前缀都有许多后缀。这使许多压缩技术成为可能。
- 可能需要将长列表分成多段，每段都小于一页。

### 3.8位图索引

**位图索引**术语常用，但如果没有对索引结构的解释，就会相当模糊。位图可以用于B-tree，也可以用于哈希索引和其他形式的索引。如图3.9所示，位图是一组整数的一种或多种表示技术。当一组整数与每个索引键相关时，索引可以是位图索引。但在后面，假设非唯一的二级B-tree索引。

数据库索引中的位图是一个相当古老的概念[65，103]，随着关系数据仓库的兴起而变得重要。唯一的要求是，==<u>索引键关联的信息和整数（即位图中位的位置）之间为一对一映射</u>==。例如，由设备号、页码和槽号组成的记录标识符可以解释为单个大整数，因此可以在位图和位图索引中编码。

此外，可以对位图分段和压缩。 对于分段，按区间划分可能的**位位置**，对这些区间进行编号，并为每个非空区间创建单独的位图。为每个段重复搜索键，并按区间编号扩展搜索键。图3.9显示了一个将列表分成多个段的示例，尽管它使用的是引用列表，而不是位图。

2^15^位的段可确保任何段的位图都可以轻松地放入数据库页；2^30^位的段大小可确保通过行程编码在压缩中使用标准整数值。将位图划分为2^15^或2^30^位的段也可以实现合理有效的更新。例如，插入单个记录只需要解压缩和重新压缩单个位图段，并且空间管理非常类似于改变传统B-tree记录的长度。

对于位图压缩，大多数方案主要依赖于行程编码。例如，==<u>WHA [126]将位图按31位划分为一组</u>==，并用计数替换多个相邻的组。压缩位图中，一个32位字包含一个指示位，加上一个31位的位图或一个计数器。计数器其中的30位用于计数，留下1位用来指示被替换的组是包含“0”还是“1”。基于字节而不是字的位图压缩方案往往会实现更紧密的压缩，但需要更昂贵的操作[126]。如果行程以变长整数编码，则尤其如此。

> ==TODO：==Fig 3.10

图3.10说明了这种压缩技术。示例(a)显示了类似于图3.9中的位图，但具有不同的第三值。示例(b)显示WAH压缩。逗号表示==<u>压缩后</u>==的字边界，带下划线的位表示==<u>字使用</u>==。位图以151组31个“0”开始。后面两个字是位图；两个位图是必需的，因为4711和4712属于两个不同的==<u>31位</u>==位图。然后是另外五组31个“0”，向前跳到4923所在的那组，即在最后31位的位图中，显示为单个“1”的那位。

没有压缩，位图索引只有在索引中几乎没有重复键值时才有空间效率。通过有效压缩，位图索引的大小约等于传统索引的大小，其中引用列表被分成段，如图3.10所示。例如，对于WAH压缩，每个引用最多需要一个为“0”的计数组加上一个31位的位图，使用记录标识符的传统方法可能每个标识符也需要64位。因此，位图索引对于稀疏和密集位图都是有用的，即对于低基数和高基数属性都有用[125，126]。

位图主要用于只读或多读少写的数据，不适用于更新密集型的数据库和索引。这是由于认识到更新压缩位图的困难，例如，在诸如WAH的行程编码方案中插入新值。另一方面，利用用数字差异压缩记录标识符列表和行程编码中的计数器非常相似。这两种压缩存储格式的更新成本应该非常相似。

位图的主要操作是创建、交集、并集、差集和扫描。创建索引或执行查询时使用位图表示查询中间结果时，会创建位图。位图交集有助于连接（“与”）谓词，并集有助于析取（“或”）谓词。注意，整数上的范围查询通常可以转换为并集，例如，`. . . between 3 and 5` 相当于 `..＝3 or ..＝4  or ..=5` 。因此，即使大多数查询谓词是求交集而非求并集，并集操作对于位图和引用列表仍然很重要。

使用位图保存中间查询结果等价于排序数据。从二级索引获取记录标识符，然后使用之从表中检索不可预知的记录数时尤其有用。在位图中收集记录标识符，并按排序顺序获取所需的数据库的记录，通常比不排序的情况下获取记录更有效。传统的排序操作可能需要比位图更多的内存和工作量。

理论上，位图可用于任何布尔属性。换句话说，位图中的位表示某个记录是否具有感兴趣的属性。上面的讨论和图3.9中的示例隐含地假设此属性与某个键值相等。因此，索引中的每个键值都有一个位图，指示具有这些键值（就是指是否有某个属性）的记录。另一种方案基于模运算[112]。 ==<u>例如，如果索引的列是32位整数，则有32位的位图。 位图的位置*k*表示**记录的键值%2^k^**非零</u>==。查询需要执行交集和联合操作。 还可以设计许其他多方案，例如基于范围谓词， O’Neil 等人[102]调研了许多设计选择。

通常，位图索引表示一对多关系，例如，键值和引用的记录标识符之间的关系。这种情况下，索引中一个的位图，特定的位被置为“1”（假设有一行记录对应于该位）。但是，在某些情况下，位图索引可能表示多对多关系。那种情况下，可以在多个位图中将相同的位置为“1”。例如，如果一个表包含两个外键以表示多对多关系，==<u>则其中一个外键列可能为二级索引中提供键值</u>==，另一个外键列由位图表示。更具体的例子，学生和课程之间的多对多的注册关系，可以通过**学生标识符**上的B-tree来表示，并用位图表示学生（选择）的课程。在所有注册该课程的学生的位图中，也就是在许多位图中，表示特定课程的位被置为“1”。

- 位图需要值和位之间的一对一关系。
- 位图和压缩位图只是表示重复（前缀）值的另一种格式。
- 位图可用于表示**与不同前缀值关联的**==所有后缀值==。
- 行程编码作为位图的一种压缩技术，类似于对整数列表进行排序，并存储相邻值之间差异的压缩方法。基于这种相似性，两种表示重复值的技术可以同样地节省空间。

### 3.9数据压缩

Data compression reduces the expense of purchasing storage devices. It also reduces the cost to house, connect, power, and cool these devices. Moreover, it can improve the effective scan bandwidth as well as the bandwidths of utilities such as defragmentation, consistency checks, backup, and restore. Flash devices, due to their high cost per unit of storage space, are likely to increase the interest in data compression for file systems, databases, etc.

B-trees are the primary data structure in databases, justifying compression techniques tuned specifically for B-tree indexes. Compression in B-tree indexes can be divided into compression of key values, compression of node references (primarily child pointers), and representation of duplicates. Duplicates have been discussed above; the other two topics are surveyed here.

For key values, prefix and suffix truncation have already been mentioned, as has single storage of non-unique key values. Compression of normalized keys has also been mentioned, albeit as a problem without published techniques. Another desirable form of compression is truncation of zeroes and spaces, with careful attention to order-preserving truncation in keys [2].

Other order-preserving compression methods seem largely ignored in database systems, for example order-preserving Huffman coding or arithmetic coding. Order-preserving dictionary codes received initial attention [127]. Their potential usage in sorting, in particular sorting in database query processing, is surveyed elsewhere [46]; many of the considerations there also apply to B-tree indexes.

For both compression and de-compression, order-preserving Huffman codes rely on binary trees. For static codes, the tree is similar to the tree for non order-preserving techniques. Construction of a Huffman code starts with each individual symbol forming a singleton set and then repeatedly merges two sets of symbols. For a standard Huffman code, the two sets with the lowest frequencies are merged. For an order-preserving Huffman code, the pair of immediate neighbors with the lowest combined frequency is chosen. Both techniques support static and adaptive codes. Adaptive methods start with a tree created as for a static method but modify it according to the actual, observed frequency of symbols in the uncompressed stream. Each such modification rotates nodes in the binary tree.

> ==TODO：==Fig 3.11

Figure 3.11, copied from [46], shows a rotation in the binary tree central to encoding and decoding in order-preserving Huffman compression. The leaf nodes represent symbols and the root-to-leaf paths represent the encodings. With a left branch encoded by a 0 and a right branch by a 1, the symbols “A,” “B,” and “C” have encodings “0,” “10,” and “11,” respectively. The branch nodes of the tree contain separator keys, very similar to separator keys in B-trees. The left tree in Figure 3.11 is designed for relatively frequent “A” symbols. If the symbol “C” is particularly frequent, the encoding tree can be rotated into the right tree, such that the symbols “A,” “B,” and “C” have encodings “00,” “01,” and “1,” respectively. The rotation from the left tree in Figure 3.11 to the right tree is worthwhile if the accumulated weight in leaf node C is higher than that in leaf node A, i.e., if effective compression is more important for leaf node C than for leaf node A. Note that the frequency of leaf node B is not relevant and the size of its encoding is not affected by the rotation, and that this tree transformation is not suitable to minimize the path to node B or the representation of B. 

Compression of B-tree child pointers may exploit the fact that neighboring nodes are likely to have been allocated in neighboring locations while a B-tree is created from a sorted stream of future index entries. In this case, child pointers in a parent page can be compressed by storing not the absolute values of pointers but their numeric differences, and by storing those in the fewest words possible [131]. In the extreme case, a form of run-length encoding can be employed that simply indicates a starting node location and the number of neighbor nodes allocated contiguously. Since careful layout of B-tree nodes can improve scan performance, such allocation of B-tree nodes is often created and maintained using appropriate space management techniques. Thus, this compression technique often applies and it is used in products. In addition to child pointers within B-tree indexes, a variant can also be applied to a list of references associated with a key value in a non-unique secondary index.

Compression using numeric differences is also a mainstay technique in document retrieval, where “an inverted index . . . records, for each distinct word or term, the list of documents that contain the term, and depending on the query modalities that are being supported, may also incorporate the frequencies and impacts of each term in each document, plus a list of the positions in each document at which that word appears. For effective compression, the lists of document and position numbers are usually sorted and transformed to the corresponding sequence of differences (or gaps) between adjacent values.” [1]. Research continues to optimize compression effectiveness, i.e., the bits required for values and length indicators for the values, and decompression bandwidth. For example, Anh and Moffat [1] evaluate schemes in which a single length indicator applies to all differences encoded in a single machine word. Many more ideas and techniques can be found in dedicated books and surveys, e.g., [124, 129].

- Various data compression schemes exist for separator keys and child pointers in branch nodes and for key values and their associated information in leaf nodes. 
-  Standard techniques are truncation of blank spaces and zeroes, representing values by their difference from a base value, and representing a sorted list of numbers by their differences. Offset-value coding is particularly effective for sorted runs in a merge sort but can also be used in B-trees. 
- Order-preserving, dynamic variants exist for Huffman compression, dictionary compression, and arithmetic compression. 

### 3.10 空间管理

和数据库的堆文件形成对比，人们有时会说B-Tree内置了记录的空间管理。另一方面，也可以说B-Tree没有提供『在那放置记录』的选择，即使多个页面都有空闲空间，也必须把新记录放置在其键值对应的那个页面内，而不能把它放在其它的页面内。

然而存在一些好时机，以实施有效的空间管理。**第一**，由于对应的节点空间不够，而导致插入失败时，我们可以选择：**精简**（即回收页内的垃圾空间）、**压缩**（重新编码页内的**Keys**，及其关联的信息）、（在兄弟节点之间实施）**负载平衡**、以及**分裂**。这个序列指出了最好的几个方法，优先考虑简单和只涉及本页的操作。很少有数据库实现了两个相邻节点的**负载平衡**，而在多与两个相邻的节点之间实施**负载平衡**，几乎就没有出现过。但是，可能会针对『某个特定的键值范围（不是整颗B-Tree）』调用碎片整理工具。

第二，由于节点分裂而需要分配新页时，如何设置新页的位置也是一种优化。如果频繁扫描大区间和索引，并且B-Tree存储在磁盘上，需要耗时的定位操作，在已经存在的页面附近分配新页就非常重要了。

第三，删除时存在同样的选择。注意，某些情况下在相邻节点之间实施负载平衡，不仅仅是一种优化的选择，而是避免下溢的需要。相比于教科书上的删除方案，一个常用的方法是忽略下溢，甚至在极端情况下允许B-Tree中存在空页，在未来的插入或是碎片整理时再完成垃圾空间的回收。

为了避免或者至少是延迟分裂节点，在创建索引、批量加载和碎片整理时，许多数据库系统都在页面上预留一些空闲空间。比如，内部节点预留10%的空闲空间，几乎不会影响扇出和树高，但事务处理时，将会减少节点分裂的开销。另外，某些系统会在磁盘上预留一些空闲页面，如大区间扫描时，如果IO的读取单元是多个B-tree节点，那么在这样的单元中『预留一些未分配的空闲页面』将会比较有利，因为分裂节点时，可在其附近快速分配空闲页，除非是大规模插入引起大量节点被分裂，否则，扫描性能不会受影响。

一个有趣的、在磁盘上管理空闲空间的方法依赖于B-tree的核心逻辑。O’Neil的SB-trees [104]在分配磁盘空间时，每次分配的是一组连续的页，称之为**节**（extent）；在创建索引和碎片整理时，会在每**节**上预留一些空闲页面。节点分裂时，在同一**节**里分配新的节点；如果由于**节**全满，无法分配新的节点，则分裂该**节**，得到两个半满的**节**，非常类似于B-tree的节点分裂；但这个简单又有前途的方法并没有获得广泛的接受。这种『“自相似”数据结构和算法』的模式，可被应用到多层的内存存储体系上。

> ==TODO：==Fig 3.12

图3.12画出了SB-tree的两类节点，**节**和**页面**都有溢出的可能，因此需要分裂成两个半满的**节**和**页面**。**页面**75.2包含的页面ID非常类似，可以轻易压缩之。当由于插入，必须分裂**页面**93.4时，则必须分裂第93**节**；多个页面（即**页面**93.3到93.5）将会被移到新**节**中。

- B-trees rigidly place a new record according to its sort key but handle space management gracefully, e.g., by load balancing among neighbor nodes.
- B-tree concepts apply not only to placement of records in pages but also to placement of pages in contiguous clusters of pages on the storage media. 

### 3.11 分裂节点

分裂叶节点时，需要在父节点插入一条分割键记录，这可能会导致父节点溢出，沿着父节点向上，需要在祖父节点再插入一条分割键记录。极限情况下，从叶节点到根节点都需要分裂，这样，必须在B-tree上加入新的根节点

上面描述的是B-tree最原始的分裂算法，称之为**叶到根节点分裂**。然而，如果多个事务或是线程共享一棵B-tree，那么一个『正在执行bottom-up，即从**叶到根节点**分裂』的线程，就有可能和另一个『正在执行搜索，即从根节点向叶节点遍历』的线程发生冲突。[Mohan 1990]里解决这个问题的方法比较激进，它限制B-tree一次只能有一个线程改变数据结构（分裂或合并节点）。解决这个问题，还有三个少一些限制的方案。

第一，由于分裂操作相对来说很少，我们可以让插入再来一次根到叶节点的遍历：第一次遍历确定在那一层分裂，第二次则在相应的层上分裂节点。如果不能如愿在上层节点插入分割键记录，那就执行第二次根到叶节点的遍历，并先分裂高层节点。可以对这次额外的遍历做些优化，比如此时，如果并没有其它线程修改上层节点，那么，我们就不必在上层的节点内再次实施二叉搜索（搜索结果已知）。

第二，从根到叶节点遍历时，首先检查其经过的每个节点是否有足够的空闲空间可以容纳几条分割键记录，并预先分裂无足够空间的内部节点[Mond and Raz 1985]，这样，一次根到叶节点遍历的就能完成所有的插入和节点分裂操作。如果每个内部节点可以容纳好几百个分割键记录，那么与真正需要的时候再分裂相比，早一点分裂实际上并不会影响B-tree的空间利用率、节点扇出和树高。可惜地是，如果分割键长度可变，这个方法就有问题，要么是分裂的决策极端保守，过早地分裂；要么是在很少的情况下，需要采用上段所述的第一种方法，再次从根到叶节点执行一次遍历。换句话说，任何情况下都要实现第一个方案。如果节点分裂很少，实现此种方法还需要完成测试案例和回归测试，这就不值得了，甚至可能都无法测量出该方法的性能收益。

第三，将节点分裂和插入分割键记录分成两步[Lehman and Yao 1981]。中间状态和图3中2-3树中的三元节点类似，它可能会持续一段长时间，不过理想情况下不会。换句话说，就是先创建一个溢出节点，而不是完整地完成一次分裂。溢出节点和其邻居节点相连，而非父节点，这就是Blink树的由来。下次遍历时，再在父节点上插入恰当的分割键记录，将溢出节点变成正常的B-tree节点。

- Some variations of the original B-tree structure enable high concurrency and efficient concurrency control. Blink-trees seem particularly promising although they seem to have been overlooked in products. 

### 3.12 小结

总之，经过几十年的研究和实现，B-tree的基本设计，包括数据结构和算法，在很多方面都已经获得改进。目前为止，我们回顾了许多工业级的实现采用的许多技术。『忽略甚至与这些技术相矛盾』的研究被视为与『商业数据库管理产品』无关。