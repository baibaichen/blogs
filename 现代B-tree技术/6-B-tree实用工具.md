## 6. B-tree 实用工具

在数据库中，除了利用B-tree索引的各种高效事务技术和查询处理方法之外，也许正是现有的大量实用工具将B-tree与其他索引技术区别开。例如，验证数据库或某些备份介质上的B-tree索引结构，可通过以任何顺序扫描数据页一次，并在内存或磁盘上保留有限的临时信息来完成。即使是为大型数据集高效创建索引，也往往需要数年才能开发出新的索引结构。例如，很长一段时间内已经出现越来越多的高效策略，用于构建和批量加载R-tree索引[23,62]，而B-tree索引则只需要排序这一简单策略，也适用于多维度的B-tree索引[6,109]。替代索引结构的可比技术通常不是新索引技术最初建议的那部分。

索引实用工具通常是集合操作，无论是创建索引时，准备一组将要索引的数据；还是验证结构时，处理从诸如B-tree之类的索引中提取的一组索引事实。因此，索引实用工具可以使用许多传统的查询处理技术，包括查询优化（例如，是连接同一个表的两个二级索引，还是扫描表的一级索引中）、分区和并行、工作负载管理（用于准入控制和调度）、和资源管理（用于内存和临时磁盘空间，或磁盘带宽的管理）。类似地，前面已经讨论过的许多事务性技术，可用在索引实用工具中。因此，以下讨论不涉及与空间管理、分区、非日志操作，在线操作的并发更新等**相关的实现问题**；相反，下面的讨论主要聚焦于尚未涵盖的方面，但与一般索引，特别是-tree索引相关的数据库实用工具。

- 实用工具对于数据库及其应用程序的高效运行至关重要。 和任何其他索引格式相比，B-tree存在更多的技术和实现。
- 实用工具通常会影响整个数据库、表或索引，经常运行很长时间。一些系统采用查询优化和查询执行中的技术和代码。

### 6.1 索引创建

虽然有些产品最初依赖重复插入来创建索引，但通过对将要索引的数据进行排序，索引创建的性能得到了很大的提高。因此，高效创建索引的技术可以分为**快速排序**、**从排序流中的构建B-tree**、**并行创建索引**、以及**创建索引时的事务**。

从排序流构建B-tree期间，B-tree的整个“右边缘”可以始终保留甚至固定在缓冲池中，以避免在缓冲池中进行冗余搜索。类似地，在线创建索引期间，可以尽可能多地保留“大”锁[48]，并仅在响应冲突请求时释放锁。或者，如果索引创建不会修改数据库的逻辑内容，则可以完全避免事务锁，因为只修改了数据库的结构。

创建新索引时通常会保留一些可用空间，用于将来的插入和更新。叶节点内的可用空间允许插入新索引时不会分裂叶节点；分支节点内的可用空间允许下层节点分裂时，不会向上级联分裂；分配单元内的空闲页面（例如一组连续页面的节或磁盘柱面）使得在分裂时没有昂贵的搜索操作，更重要的是，这使得后续所有的**范围查询**和**索引扫描**没有昂贵的搜索操作。并非所有系统都提供控制这类空闲空间的接口，因为很难预测在未来的索引使用过程中，哪些参数值最佳，而且，也可能不会精确地遵循控制参数。例如，配置每个叶中所需的空闲空间为10%，则前缀B-trees [10]可能选择相邻叶的键值范围，这样分隔键较短，左节点包含0%到20%的空闲空间。

> ==TODO：== Fig.6.1

图6.1显示了刚刚创建完索引后，具有可变大小记录的固定大小页面。所有页面都差不多，但不一定是满的。在一定数量的页面（此处为3）之后，预留的空页面可用于将来的页面拆分。

如果索引的键值不唯一，**排序顺序**应包括足够的引用信息，以使索引项具有唯一性，如前所述，这将有助于并发控制、日志记录和恢复、以及索引项的最终删除。例如，在表中删除逻辑行时，必须删除所有索引中与该行相关的所有记录。在不唯一的二级索引中，此**排序顺序**可以有效地查找要删除的正确索引项。

如果二级索引“有太多的重复键”，即每个唯一键值都有大量引用，则各种压缩方法可用于减小索引的大小，从而降低将初始索引写入磁盘的时间，也提高了扫描索引（查询处理时）或是复制索引（执行复制或备份操作时）的速度。最传统的数据结构是把计数器和每个唯一键值的引用列表关联起来[66]。在许多情况下，与完整参考值相比，可以更紧凑地保存相邻参考之间的数值差异。适当的排序可以有效地构造此类差异列表；事实上，此类列表的构造可以建模为聚合函数，从而在外部合并排序时，可以减少写入临时存储的数据量。==也可以使用位图==。尽早根据相等的键值对即将插入的索引项进行分组，不仅能够实现压缩，从而减少排序期间的I/O，而且在合并步骤中也可以减少比较，因为在索引项分组之后，每组只需要一个代表性的键值参与合并逻辑。

> ==TODO：== Fig.6.2

图6.2（来自[46]）用三路归并说明了这一点。**带下划线的键**代表归并输入和归并输出中的组。因为值1、2和3已经通过了合并逻辑，在归并输入中删除了它们。**值2**的两个副本都标记为其输入组中的代表；在输出中（下一层归并会用到），只标记了第一个副本而没标记第二个副本。**值3**在输入中有一个副本未被标记，因此不参与到当前归并步骤的合并逻辑。在下一层归并中，值3的两个副本将不参与合并逻辑。**值4**节省的成本更多：六个副本中只有两个参与当前归并步骤的合并逻辑，而下一层归并中，六个副本中只有一个参与合并逻辑。

创建大型索引期间，另一个可能问题是需要临时空间来保存**临时有序的一组文件**。请注意，一旦合并进程**消费**了某个临时有序的文件，或是其中的一页数据，可能会立即“回收”它们。因此无论是默认还是作为一个选项，一些商业数据库系统将这些**临时有序的一组文件**，存储在**为最终索引指定**的磁盘空间中。最后的一步归并时，为正在创建的索引回收页面。如果目标空间是唯一可用的磁盘空间，那么除了将其用于保存**临时有序的文件**之外，没有其他选择，尽管这种选择的==一个明显问题是目标空间通常位于镜像磁盘或冗余的RAID磁盘上==。此外，在目标空间中进行排序可能会导致最终索引相当碎片化，因为以随机顺序从归并的输入中回收页面，。因此，顺序扫描最终索引（例如大范围查询）将导致许多磁盘查找。

> ==TODO：== Fig.6.3

图6.3说明了排序的数据源大于临时空间的情况。因此，临时有序的文件不能放在保存临时数据的标准位置， 而是将它们放在目标空间中。当归并步骤消耗临时有序文件时，必须立即释放磁盘空间，以便为归并步骤的输出创建可用空间。

有两种可能的解决方案。**首先**，归并完成时可以将临时文件页面释放到全局可用页面池，最终创建索引时，尝试从那里分配大的连续磁盘空间。但是，除非分配算法搜索连续可用空间非常有效，否则大多数分配将具有相同的小尺寸，并处于归并过程中回收的空间。**其次**，从初始的临时文件到中间步骤的临时文件之间、中间临时文件之间、以及从临时文件到最终的的索引之间，可以按较大的单元（通常是I/O单元的倍数）回收空间。例如，如果此倍数为8，那么保留不超过磁盘页面大小8倍的内存空间，以便一起延迟回收，这在创建大型索引时通常是可接受的开销。其好处是，在大型有序扫描中，顺序扫描索引或大范围扫描完整索引所需的查找次数**要少8倍**。

如果创建索引的排序操作生成的临时有序文件，保存在最终存放B-tree的空间，则从系统或介质故障中恢复时，必须非常精确地重复原始排序操作。否则，恢复可能会以不同于原始执行的**方式**放置B-tree记录，并且描述B-tree更新的后续日志记录不能用于恢复的B-tree索引。具体来说，初始临时有序文件大小、合并步骤的顺序、合并扇入、合并输入的选择等，所有这些信息要么在日志中记录，要么由创建索引的日志信息所指定，例如，授予排序操作的内存分配。因此，在恢复期间，必须为排序提供与原始执行期间相同的内存。**也必须精确地重复排序数据的扫描（比如存在异步预读），而不必排列输入页或记录，如果在不同硬件上恢复原始执行，例如在灾难性硬件故障（如洪水或火灾）之后，这可能是一个问题**。精确重复执行，可能还需要在索引创建期间禁止自适应存储器分配，即，存储器分配，初始临时有序文件大小，合并扇入都会响应索引创建期间的内存争用的波动。

不仅可以使用分组和聚合，还可以使用查询处理中的各种技术来创建索引，包括查询优化和查询执行技术。例如，创建二级索引的标准技术是扫描表；但是，如果存在两个或多个二级索引包含所有必需的列，并且一起扫描的速度比扫描表快，则查询优化器可能会选择扫描这些现有索引，并关联结果以构造新索引的记录。查询优化在物化视图时发挥的作用更大，在某些系统中，物化视图被建模为创建索引不是创建表。

对于并行创建索引，可以使用标准的并行查询执行技术，以所需的排序顺序生成将要索引的数据项。剩下的问题是并行插入到新的B-tree中。一种方法是创建多个独立的、键范围不相交的B-tree，并用单个叶到根路径把它们“缝合”在一起，并在相邻节点之间实现负载平衡。

- 高效的B-tree创建依赖于有效的排序和提供事务保证，而无需在日志中记录新的索引内容。
- 用于创建索引的命令通常有许多选项，例如关于压缩的选项、为后续更新留下多少空闲空间的选项、以及临时空间的选项（用于排序索引数据）。

### 6.2 索引删除
删除索引可能看起来相当简单，但由于各种原因，可能不是这样。例如，如果索引删除是较大事务的一部分，那么这个事务是否会阻止其他所有事务访问表，即使索引删除事务可能已中止？索引删除是否可以在线，即是否可以并发查询和更新表？再举一例，如果一个表同时具有主索引（非冗余）和一些二级索引（通过搜索键指向主索引中的记录），那么当主索引被删除时需要多少工作量？ 也许主索引仅释放分支节点，保留的叶节点变成成立堆文件，重建二级索引需要多长时间？同样，索引是否可以在线删除？

最后，索引可能非常大，更新分配信息（例如，空闲空间映射）可能需要相当长的时间。这种情况下，“即时”删除索引可能只是在适当的目录（**catalog**）记录中声明索引已**过时**。这有点类似于幻影记录，不过幻影指示符仅与其出现的记录有关，而**过时指示符**与目录记录所代表的整个索引有关。此外，幻影记录可在其创建之后很久就才被删除，但应该尽快释放索引空间，因为这可能涉及大量的存储空间。即使在释放此空间之前或过程中，系统发生崩溃，在成功重启之后，也应该快速继续该过程。需要适当的恢复日志记录，精心设计可最大限度地减少日志量，即使在尝试恢复时重复崩溃，也可确保成功。

作为目录记录中的**过时指示符**的替代，可用内存数据结构表示延迟的删除工作。请注意，此数据结构是服务器状态（内存中）的一部分，而不是数据库状态（磁盘上）的一部分。因此，只要服务器在延迟工作完成之前不崩溃，此数据结构就有效。 对于这种可能性，应该在恢复日志中记录数据结构的创建和最终删除。 因此，这种替代设计不会节省日志工作量。此外，在正常处理期间、==可能发生崩溃后的恢复期间==以及==随后的恢复期间==，这两种设计都要求支持中间状态。        

- 索引删除可能很复杂，特别是如果必须创建一些结构作为响应。 
- 通过延迟更新**管理可用空间的数据结构**，可以即时删除索引。其他许多实用工具可以使用这个执行模型，但是索引删除似乎是最明显的候选者。

### 6.3 索引重建

重建现有索引有多种原因，有些系统需要在高效整理碎片时重建索引，特别是可以在线或增量重建索引。

如果主索引中的搜索键不唯一，为了确保唯一引用，需要在**人工字段**中增加新值，则可能需要重建主索引。 类似地，移动有物理记录标识符的表需要修改所有引用。 请注意，这两个操作都需要重建所有二级索引才能反映修改后的引用值。

当主索引更改时，即主索引中**主键的列集**发生更改时，需要重建所有二级索引。如果仅仅改变它们的顺序，则不需严格地重建二级索引和分配新引用。更新所有现有的二级索引可能比重建索引慢，==部分原因是更新索引需要在恢复日志中保存完整信息，而重建索引不必记录创建索引的信息（仅需要记录分配信息）==。

> ==TODO：== Fig.6.4

图6.4的查询执行计划，说明如何重建表的主索引以及随后的三个二级索引。扫描从当前主索引或堆文件中读取数据，排序准备填充新的主索引。在临时存储中，缓存（spool）操作只保留二级索引所需的那些列。如果反复扫描新的主索引比写入和重新读取spool数据的成本更低，则可以省略spool操作。==或者，如前面与图6.4相关的讨论所述，spool之后的每个单独的排序可以起到spool操作的作用==。

- 可以在（由于软件或硬件故障）损坏索引后重建索引，或在需要整理碎片但删除和重建更快时重建索引。
- 重建主索引时，通常也必须重建二级索引。 各种优化适用于此操作，包括一些通常不用于标准查询处理的优化。

> ==TODO:==
>
> 1. **artificial field**: 人工字段。这个还要结合全文来看
> 2. 这章反复说到恢复，说到日志，有必要回顾下数据库的日志操作
> 3. *前面与6.4相关的讨论*，这里的==**前面**==是指5.10节吗？

### 6.4 批量插入

**批量插入**，也称为增量加载、滚入或信息捕获，是许多数据库中非常频繁的操作，尤其是数据仓库、数据集市、或其他数据库，它们主要包含事件或活动（如销售事务）信息，而不是状态（如账户余额）信息。当夜间数据库维护或初始概念验证实现的时间窗口很短时，批量插入的性能和可扩展性有时会决定竞争供应商。

任何对批量插入的性能或带宽的分析，都必须区分**即时带宽**和**持续带宽**，以及**在线加载**和**离线加载**。**第一个区别**是由于物化视图，索引，直方图等统计数据的延迟维护。例如，分区B-trees[43]可以实现**很高的即时负载带宽**（基本上，以磁盘写入速度追加到B-tree）。但是最终，查询性能会随着每个B-tree中的额外分区而恶化，需要通过合并分区进行重组；在确定要一直维持这么高的负载带宽时，必须考虑这种重组。

第二个区别在于在加载操作期间，是否能为应用程序提供查询和更新服务。例如，某些数据库供应商建议，在其某些版本大量插入之前删除所有索引，例如插入大于现有表大小的1％。 这是由于索引插入的性能不佳；为先前表大小的101%重建所有索引，可能比插入等于表大小1%的数据更快。

用于优化批量插入B-tree的技术可分为两组。两组都依赖某种形式的缓冲来延迟B-tree维护，并获得一定的规模经济性。第一组主要研究B-tree的结构并缓冲分支节点中的插入[74]。因此，B-tree节点非常大，==仅限于小扇出==，或者==<u>”每边“</u>==需要额外存储。第二组利用B-tree而不修改它们的结构，通过使用多个B-tree[100]，或通过人工前导键字段[43]在单个B-tree中创建分区。在所有情况下，具有活动插入的页面或分区都保留在缓冲池中。各种方法的相对性能，特别是在持续带宽方面，尚未通过实验研究。下面的一些简单计算**强调**了对负载带宽的主要影响。

> ==TODO：== Fig.6.5

图6.5显示了缓冲插入的B-tree节点，例如根节点或分支节点。有两个分隔符键（11和47），有三个指针指向同一个B-tree内子节点，以及每个子指针带有一组缓冲的插入。在二级索引中，索引项包含一个键值，一个指向表主索引的记录引用，此处以“ref”表示。换句话说，每个缓冲插入数据项未来都应该存储在叶节点。中间子节点的缓冲插入远小于左边子节点的缓冲插入，这可能是由于数据倾斜，或插入到中间子节点刚刚发生了==<u>分裂传播</u>==。右边子节点的缓冲的修改操作，不仅包括插入还包括删除（键值72）。主索引之前的更新，要确保删除的值确实存在于二级索引中，仅在二级索引中缓冲删除才可行。

分区B-tree的本质是通过人工前导键字段来维护单个B-树中的分区，使用从**外部归并排序**中众所周知的归并步骤，高效地在线重组和优化这样的B-tree。此关键字字段可能是2或4字节的整数。==<u>默认情况下，B-tree中所有记录中该字段是相同的单个值，分区B-tree的大多数技术都依赖于利用多个可选值，大多数情况下是临时利用，少量技术是永久利用</u>==。如果关系数据库中的表或视图有多个索引，则每个索引都有自己的人工前导关键字字段。这些字段中的值不在索引之间协调或传播，也就是说，每个人工引导关键字段都是单个B-tree内部的数据结构，这样每个B-tree就可以独立地进行重组和优化。如果一个表或索引是水平分区的，并用多个B-tree表示，那么应该为每个分区分别定义人工前导关键字字段。

> ==TODO：== Fig.6.6

图6.6说明了人工前导关键字字段如何将B-tree中的记录划分为分区。在每个分区中，记录按用户定义的键进行排序，索引和搜索，就像在标准B-tree中一样。 在本例中，分区0可能是主分区，而分区3和4包含最近的插入，在内存中排序后作为新分区追加到B-tree。最后一个分区可能保留在缓冲池中，可以非常有效地吸收随机插入。当其大小超过可用缓冲池时，通过显式请求、或在缓冲池中的标准页面替换期间，按需将其写入磁盘，然后启动一个新分区。或者，显式排序操作可以对大量插入进行排序，然后追加一个或多个分区。显式排序实际上只生成有序的数据文件，然后将它们作为分区追加到分区B-tree。

初始加载操作应将新插入的记录或新填充的页面复制到恢复日志中，以便即使在介质或系统发生故障时也能保证新的数据库内容。重组B-tree可以避免（在恢复日志中）记录内容，因此通过==<u>仔细的写入顺序</u>==，只需要在日志中记录B-tree索引中的结构变化。具体而言，对于有记录或指针被删除的页面，在新位置写入记录新副本后，才能在旧位置覆盖其早期版本。对于其他形式的B-tree重组，已经在[44,89,130]描述了通过==<u>仔细写入顺序</u>==，从而启用最小的日志记录。对于分区B-tree，批量插入后将向其追加新分区，也适用该技术合并分区B-tree的。

考虑批量插入一个表的带宽计算示例，该表包含一个主索引和三个二级索引，都存储在一个磁盘上，磁盘支持每秒200次读写操作（100个读写对）和100 MB/s读写带宽（假设是连续I/O，访问延迟可忽略不计）。 在示例计算中，主索引记录大小为1 KB，二级索引记录大小为0.02 KB，包括页面和记录标头的开销，以及空闲空间等。为简单起见，我们假设一个热缓冲池，只有叶节点需要I/O。**基准计划**依赖于随机插入4个索引，每个索引需要一次读取和一次写入操作。 每插入一行数据需要8次I/O，每秒可在此表中插入25行。每个磁盘驱动器插入的持续带宽为25×1 KB=25KBs = 0.025 MB/s。 这是插入的即时和持续带宽。

对于依赖索引删除和插入后重建索引的计划，假设索引删除几乎是即时的。 如果不存在索引，则即时插入带宽等于磁盘写入带宽。将表大小增加1%后，索引创建必须扫描插入数据量的**101**倍，然后将该数据量的**106％**写入索引的4个临时有序文件（在排序二级索引时共享临时有序文件），最后将它们合并到索引中：对于给定的添加数据量，I/O量为==**1 + 101×(1 + 3×1.06)=423**==，等于该量的423倍；在100 MB/s时，这允许100/423 MB/s = 0.236 MB/s的持续插入带宽。 虽然与100 MB/s相比这可能看起来很差，但它比随机插入快十倍，因此供应商推荐这种方案并不奇怪。

对于**在每个分支节点缓冲插入**的B-tree，假设每个节点中的缓冲区空间比节点中的子指针多插入10倍。==<u>溢出时的传播集中在具有最多未完成插入的子节点上；让我们假设平均可以传播20条记录</u>==。因此，每插入20条记录强制读写一个B-tree叶节点，或每个记录插入需要**1/20**的IO读写对。另一方面，具有缓冲区的B-tree节点要大得多，因此每个记录插入可能需要读写一个叶节点及其父节点，这种情况下插入每个记录强制**2/20=1/10** IO读写对。在包含一个主索引和三个二级索引（即总共4个B树）的示例表中，这些假设导致每个插入的记录有4/10的IO读写对。假定磁盘硬件每秒100对读写，因此支持每秒250条记录插入或0.250 MB/s的持续插入带宽。除了与以前的方法相比带宽略有改善外，此技术还保留和维护原始的B-tree索引，并允许在整个加载过程中进行查询处理。

在假定的磁盘硬件中，分区B-tree允许100MB/s的即时插入带宽，即，纯粹追加在内存工作空间排好序的新分区，排序算法是快排或是==**置换选择排序**==。优化B-tree，即合并分区B-tree中的一层，需要读取和写入分区，可以处理50MB/s（的插入数据）。如果**添加的分区达到主分区大小的33％时**调用重组，则添加给定数量的数据，需要相同数量的初始写入，加上此数量4倍的读取和写入以进行重组。对于单个B-tree，一次I/O放大9倍产生11MB/s的持续插入带宽。对于示例表，有主索引和三个二级索引，必须在所有索引之间划分该带宽，从而得到11 MB/s ÷(1 + 3×0.02) KB = 10 MB/s的持续插入带宽。这比其他**批量加载**技术快一个数量级。此外，在初始捕获新信息和B-tree重组期间，仍然可能处理查询。多层合并方案可以进一步增加该带宽，因为可以较少地重新组织主分区，但是现有分区的数量可以保持很小。

除了传统的数据库，B-tree索引也可以用于数据流。 **如果仅在索引中保留最近的数据项**，则需要批量插入技术和批量删除技术。 因此，索引流将在下一节中讨论。

- 批量插入的效率（也称为加载，滚入或信息捕获）对于数据库操作至关重要。
- 在某些实现中，维护索引的效率非常低，以至于在执行大型加载操作之前，索引会被删除。已经发布并实现了各种技术，以加速对B-tree索引的批量插入。它们的持续插入带宽相差几个数量级。





















