## 6. B-tree 实用工具

在数据库中，除了利用B-tree索引的各种高效事务技术和查询处理方法之外，也许正是现有的大量实用工具将B-tree与其他索引技术区别开。例如，验证数据库或某些备份介质上的B-tree索引结构，可通过以任何顺序扫描数据页一次，并在内存或磁盘上保留有限的临时信息来完成。即使是为大型数据集高效创建索引，也往往需要数年才能开发出新的索引结构。例如，很长一段时间内已经出现越来越多的高效策略，用于构建和批量加载R-tree索引[23,62]，而B-tree索引则只需要排序这一简单策略，也适用于多维度的B-tree索引[6,109]。替代索引结构的可比技术通常不是新索引技术最初建议的那部分。

索引实用工具通常是集合操作，无论是创建索引时，准备一组将要索引的数据；还是验证结构时，处理从诸如B-tree之类的索引中提取的一组索引事实。因此，索引实用工具可以使用许多传统的查询处理技术，包括查询优化（例如，是连接同一个表的两个二级索引，还是扫描表的一级索引中）、分区和并行、工作负载管理（用于准入控制和调度）、和资源管理（用于内存和临时磁盘空间，或磁盘带宽的管理）。类似地，前面已经讨论过的许多事务性技术，可用在索引实用工具中。因此，以下讨论不涉及与空间管理、分区、非日志操作，在线操作的并发更新等**相关的实现问题**；相反，下面的讨论主要聚焦于尚未涵盖的方面，但与一般索引，特别是-tree索引相关的数据库实用工具。

- 实用工具对于数据库及其应用程序的高效运行至关重要。 和任何其他索引格式相比，B-tree存在更多的技术和实现。
- 实用工具通常会影响整个数据库、表或索引，经常运行很长时间。一些系统采用查询优化和查询执行中的技术和代码。

### 6.1 索引创建

虽然有些产品最初依赖重复插入来创建索引，但通过对将要索引的数据进行排序，索引创建的性能得到了很大的提高。因此，高效创建索引的技术可以分为**快速排序**、**从排序流中的构建B-tree**、**并行创建索引**、以及**创建索引时的事务**。

从排序流构建B-tree期间，B-tree的整个“右边缘”可以始终保留甚至固定在缓冲池中，以避免在缓冲池中进行冗余搜索。类似地，在线创建索引期间，可以尽可能多地保留“大”锁[48]，并仅在响应冲突请求时释放锁。或者，如果索引创建不会修改数据库的逻辑内容，则可以完全避免事务锁，因为只修改了数据库的结构。

创建新索引时通常会保留一些可用空间，用于将来的插入和更新。叶节点内的可用空间允许插入新索引时不会分裂叶节点；分支节点内的可用空间允许下层节点分裂时，不会向上级联分裂；分配单元内的空闲页面（例如一组连续页面的节或磁盘柱面）使得在分裂时没有昂贵的搜索操作，更重要的是，这使得后续所有的**范围查询**和**索引扫描**没有昂贵的搜索操作。并非所有系统都提供控制这类空闲空间的接口，因为很难预测在未来的索引使用过程中，哪些参数值最佳，而且，也可能不会精确地遵循控制参数。例如，配置每个叶中所需的空闲空间为10%，则前缀B-trees [10]可能选择相邻叶的键值范围，这样分隔键较短，左节点包含0%到20%的空闲空间。

> ==TODO：== Fig.6.1

图6.1显示了刚刚创建完索引后，具有可变大小记录的固定大小页面。所有页面都差不多，但不一定是满的。在一定数量的页面（此处为3）之后，预留的空页面可用于将来的页面拆分。

如果索引的键值不唯一，**排序顺序**应包括足够的引用信息，以使索引项具有唯一性，如前所述，这将有助于并发控制、日志记录和恢复、以及索引项的最终删除。例如，在表中删除逻辑行时，必须删除所有索引中与该行相关的所有记录。在不唯一的二级索引中，此**排序顺序**可以有效地查找要删除的正确索引项。

如果二级索引“有太多的重复键”，即每个唯一键值都有大量引用，则各种压缩方法可用于减小索引的大小，从而降低将初始索引写入磁盘的时间，也提高了扫描索引（查询处理时）或是复制索引（执行复制或备份操作时）的速度。最传统的数据结构是把计数器和每个唯一键值的引用列表关联起来[66]。在许多情况下，与完整参考值相比，可以更紧凑地保存相邻参考之间的数值差异。适当的排序可以有效地构造此类差异列表；事实上，此类列表的构造可以建模为聚合函数，从而在外部合并排序时，可以减少写入临时存储的数据量。==也可以使用位图==。尽早根据相等的键值对即将插入的索引项进行分组，不仅能够实现压缩，从而减少排序期间的I/O，而且在合并步骤中也可以减少比较，因为在索引项分组之后，每组只需要一个代表性的键值参与合并逻辑。

> ==TODO：== Fig.6.2

图6.2（来自[46]）用三路归并说明了这一点。**带下划线的键**代表归并输入和归并输出中的组。因为值1、2和3已经通过了合并逻辑，在归并输入中删除了它们。**值2**的两个副本都标记为其输入组中的代表；在输出中（下一层归并会用到），只标记了第一个副本而没标记第二个副本。**值3**在输入中有一个副本未被标记，因此不参与到当前归并步骤的合并逻辑。在下一层归并中，值3的两个副本将不参与合并逻辑。**值4**节省的成本更多：六个副本中只有两个参与当前归并步骤的合并逻辑，而下一层归并中，六个副本中只有一个参与合并逻辑。

创建大型索引期间，另一个可能问题是需要临时空间来保存**临时有序的一组文件**。请注意，一旦合并进程**消费**了某个临时有序的文件，或是其中的一页数据，可能会立即“回收”它们。因此无论是默认还是作为一个选项，一些商业数据库系统将这些**临时有序的一组文件**，存储在**为最终索引指定**的磁盘空间中。最后的一步归并时，为正在创建的索引回收页面。如果目标空间是唯一可用的磁盘空间，那么除了将其用于保存**临时有序的文件**之外，没有其他选择，尽管这种选择的==一个明显问题是目标空间通常位于镜像磁盘或冗余的RAID磁盘上==。此外，在目标空间中进行排序可能会导致最终索引相当碎片化，因为以随机顺序从归并的输入中回收页面，。因此，顺序扫描最终索引（例如大范围查询）将导致许多磁盘查找。

> ==TODO：== Fig.6.3

图6.3说明了排序的数据源大于临时空间的情况。因此，临时有序的文件不能放在保存临时数据的标准位置， 而是将它们放在目标空间中。当归并步骤消耗临时有序文件时，必须立即释放磁盘空间，以便为归并步骤的输出创建可用空间。

有两种可能的解决方案。**首先**，归并完成时可以将临时文件页面释放到全局可用页面池，最终创建索引时，尝试从那里分配大的连续磁盘空间。但是，除非分配算法搜索连续可用空间非常有效，否则大多数分配将具有相同的小尺寸，并处于归并过程中回收的空间。**其次**，从初始的临时文件到中间步骤的临时文件之间、中间临时文件之间、以及从临时文件到最终的的索引之间，可以按较大的单元（通常是I/O单元的倍数）回收空间。例如，如果此倍数为8，那么保留不超过磁盘页面大小8倍的内存空间，以便一起延迟回收，这在创建大型索引时通常是可接受的开销。其好处是，在大型有序扫描中，顺序扫描索引或大范围扫描完整索引所需的查找次数**要少8倍**。

如果创建索引的排序操作生成的临时有序文件，保存在最终存放B-tree的空间，则从系统或介质故障中恢复时，必须非常精确地重复原始排序操作。否则，恢复可能会以不同于原始执行的**方式**放置B-tree记录，并且描述B-tree更新的后续日志记录不能用于恢复的B-tree索引。具体来说，初始临时有序文件大小、合并步骤的顺序、合并扇入、合并输入的选择等，所有这些信息要么在日志中记录，要么由创建索引的日志信息所指定，例如，授予排序操作的内存分配。因此，在恢复期间，必须为排序提供与原始执行期间相同的内存。**也必须精确地重复排序数据的扫描（比如存在异步预读），而不必排列输入页或记录，如果在不同硬件上恢复原始执行，例如在灾难性硬件故障（如洪水或火灾）之后，这可能是一个问题**。精确重复执行，可能还需要在索引创建期间禁止自适应存储器分配，即，存储器分配，初始临时有序文件大小，合并扇入都会响应索引创建期间的内存争用的波动。

不仅可以使用分组和聚合，还可以使用查询处理中的各种技术来创建索引，包括查询优化和查询执行技术。例如，创建二级索引的标准技术是扫描表；但是，如果存在两个或多个二级索引包含所有必需的列，并且一起扫描的速度比扫描表快，则查询优化器可能会选择扫描这些现有索引，并关联结果以构造新索引的记录。查询优化在物化视图时发挥的作用更大，在某些系统中，物化视图被建模为创建索引不是创建表。

对于并行创建索引，可以使用标准的并行查询执行技术，以所需的排序顺序生成将要索引的数据项。剩下的问题是并行插入到新的B-tree中。一种方法是创建多个独立的、键范围不相交的B-tree，并用单个叶到根路径把它们“缝合”在一起，并在相邻节点之间实现负载平衡。

- 高效的B-tree创建依赖于有效的排序和提供事务保证，而无需在日志中记录新的索引内容。
- 用于创建索引的命令通常有许多选项，例如关于压缩的选项、为后续更新留下多少空闲空间的选项、以及临时空间的选项（用于排序索引数据）。

### 6.2 索引删除
删除索引可能看起来相当简单，但由于各种原因，可能不是这样。例如，如果索引删除是较大事务的一部分，那么这个事务是否会阻止其他所有事务访问表，即使索引删除事务可能已中止？索引删除是否可以在线，即是否可以并发查询和更新表？再举一例，如果一个表同时具有主索引（非冗余）和一些二级索引（通过搜索键指向主索引中的记录），那么当主索引被删除时需要多少工作量？ 也许主索引仅释放分支节点，保留的叶节点变成成立堆文件，重建二级索引需要多长时间？同样，索引是否可以在线删除？

最后，索引可能非常大，更新分配信息（例如，空闲空间映射）可能需要相当长的时间。这种情况下，“即时”删除索引可能只是在适当的目录（**catalog**）记录中声明索引已**过时**。这有点类似于幻影记录，不过幻影指示符仅与其出现的记录有关，而**过时指示符**与目录记录所代表的整个索引有关。此外，幻影记录可在其创建之后很久就才被删除，但应该尽快释放索引空间，因为这可能涉及大量的存储空间。即使在释放此空间之前或过程中，系统发生崩溃，在成功重启之后，也应该快速继续该过程。需要适当的恢复日志记录，精心设计可最大限度地减少日志量，即使在尝试恢复时重复崩溃，也可确保成功。

作为目录记录中的**过时指示符**的替代，可用内存数据结构表示延迟的删除工作。请注意，此数据结构是服务器状态（内存中）的一部分，而不是数据库状态（磁盘上）的一部分。因此，只要服务器在延迟工作完成之前不崩溃，此数据结构就有效。 对于这种可能性，应该在恢复日志中记录数据结构的创建和最终删除。 因此，这种替代设计不会节省日志工作量。此外，在正常处理期间、==可能发生崩溃后的恢复期间==以及==随后的恢复期间==，这两种设计都要求支持中间状态。        

- 索引删除可能很复杂，特别是如果必须创建一些结构作为响应。 
- 通过延迟更新**管理可用空间的数据结构**，可以即时删除索引。其他许多实用工具可以使用这个执行模型，但是索引删除似乎是最明显的候选者。

### 6.3 索引重建

重建现有索引有多种原因，有些系统需要在高效整理碎片时重建索引，特别是可以在线或增量重建索引。

如果主索引中的搜索键不唯一，为了确保唯一引用，需要在**人工字段**中增加新值，则可能需要重建主索引。 类似地，移动有物理记录标识符的表需要修改所有引用。 请注意，这两个操作都需要重建所有二级索引才能反映修改后的引用值。

当主索引更改时，即主索引中**主键的列集**发生更改时，需要重建所有二级索引。如果仅仅改变它们的顺序，则不需严格地重建二级索引和分配新引用。更新所有现有的二级索引可能比重建索引慢，==部分原因是更新索引需要在恢复日志中保存完整信息，而重建索引不必记录创建索引的信息（仅需要记录分配信息）==。

> ==TODO：== Fig.6.4

图6.4的查询执行计划，说明如何重建表的主索引以及随后的三个二级索引。扫描从当前主索引或堆文件中读取数据，排序准备填充新的主索引。在临时存储中，缓存（spool）操作只保留二级索引所需的那些列。如果反复扫描新的主索引比写入和重新读取spool数据的成本更低，则可以省略spool操作。==或者，如前面与图6.4相关的讨论所述，spool之后的每个单独的排序可以起到spool操作的作用==。

- 可以在（由于软件或硬件故障）损坏索引后重建索引，或在需要整理碎片但删除和重建更快时重建索引。
- 重建主索引时，通常也必须重建二级索引。 各种优化适用于此操作，包括一些通常不用于标准查询处理的优化。

> ==TODO:==
>
> 1. **artificial field**: 人工字段。这个还要结合全文来看
> 2. 这章反复说到恢复，说到日志，有必要回顾下数据库的日志操作
> 3. *前面与6.4相关的讨论*，这里的==**前面**==是指5.10节吗？

### 6.4 批量插入

**批量插入**，也称为增量加载、滚入或信息捕获，是许多数据库中非常频繁的操作，尤其是数据仓库、数据集市、或其他数据库，它们主要包含事件或活动（如销售事务）信息，而不是状态（如账户余额）信息。当夜间数据库维护或初始概念验证实现的时间窗口很短时，批量插入的性能和可扩展性有时会决定竞争供应商。

任何对批量插入的性能或带宽的分析，都必须区分**即时带宽**和**持续带宽**，以及**在线加载**和**离线加载**。**第一个区别**是由于物化视图，索引，直方图等统计数据的延迟维护。例如，分区B-trees[43]可以实现**很高的即时负载带宽**（基本上，以磁盘写入速度追加到B-tree）。但是最终，查询性能会随着每个B-tree中的额外分区而恶化，需要通过合并分区进行重组；在确定要一直维持这么高的负载带宽时，必须考虑这种重组。

第二个区别在于在加载操作期间，是否能为应用程序提供查询和更新服务。例如，某些数据库供应商建议，在其某些版本大量插入之前删除所有索引，例如插入大于现有表大小的1％。 这是由于索引插入的性能不佳；为先前表大小的101%重建所有索引，可能比插入等于表大小1%的数据更快。

用于优化批量插入B-tree的技术可分为两组。两组都依赖某种形式的缓冲来延迟B-tree维护，并获得一定的规模经济性。第一组主要研究B-tree的结构并缓冲分支节点中的插入[74]。因此，B-tree节点非常大，==仅限于小扇出==，或者==<u>”每边“</u>==需要额外存储。第二组利用B-tree而不修改它们的结构，通过使用多个B-tree[100]，或通过人工前导键字段[43]在单个B-tree中创建分区。在所有情况下，具有活动插入的页面或分区都保留在缓冲池中。各种方法的相对性能，特别是在持续带宽方面，尚未通过实验研究。下面的一些简单计算**强调**了对负载带宽的主要影响。

> ==TODO：== Fig.6.5

图6.5显示了缓冲插入的B-tree节点，例如根节点或分支节点。有两个分隔符键（11和47），有三个指针指向同一个B-tree内子节点，以及每个子指针带有一组缓冲的插入。在二级索引中，索引项包含一个键值，一个指向表主索引的记录引用，此处以“ref”表示。换句话说，每个缓冲插入数据项未来都应该存储在叶节点。中间子节点的缓冲插入远小于左边子节点的缓冲插入，这可能是由于数据倾斜，或插入到中间子节点刚刚发生了==<u>分裂传播</u>==。右边子节点的缓冲的修改操作，不仅包括插入还包括删除（键值72）。主索引之前的更新，要确保删除的值确实存在于二级索引中，仅在二级索引中缓冲删除才可行。

分区B-tree的本质是通过人工前导键字段来维护单个B-树中的分区，使用从**外部归并排序**中众所周知的归并步骤，高效地在线重组和优化这样的B-tree。此关键字字段可能是2或4字节的整数。==<u>默认情况下，B-tree中所有记录中该字段是相同的单个值，分区B-tree的大多数技术都依赖于利用多个可选值，大多数情况下是临时利用，少量技术是永久利用</u>==。如果关系数据库中的表或视图有多个索引，则每个索引都有自己的人工前导关键字字段。这些字段中的值不在索引之间协调或传播，也就是说，每个人工引导关键字段都是单个B-tree内部的数据结构，这样每个B-tree就可以独立地进行重组和优化。如果一个表或索引是水平分区的，并用多个B-tree表示，那么应该为每个分区分别定义人工前导关键字字段。

> ==TODO：== Fig.6.6

图6.6说明了人工前导关键字字段如何将B-tree中的记录划分为分区。在每个分区中，记录按用户定义的键进行排序，索引和搜索，就像在标准B-tree中一样。 在本例中，分区0可能是主分区，而分区3和4包含最近的插入，在内存中排序后作为新分区追加到B-tree。最后一个分区可能保留在缓冲池中，可以非常有效地吸收随机插入。当其大小超过可用缓冲池时，通过显式请求、或在缓冲池中的标准页面替换期间，按需将其写入磁盘，然后启动一个新分区。或者，显式排序操作可以对大量插入进行排序，然后追加一个或多个分区。显式排序实际上只生成有序的数据文件，然后将它们作为分区追加到分区B-tree。

初始加载操作应将新插入的记录或新填充的页面复制到恢复日志中，以便即使在介质或系统发生故障时也能保证新的数据库内容。重组B-tree可以避免（在恢复日志中）记录内容，因此通过==<u>仔细的写入顺序</u>==，只需要在日志中记录B-tree索引中的结构变化。具体而言，对于有记录或指针被删除的页面，在新位置写入记录新副本后，才能在旧位置覆盖其早期版本。对于其他形式的B-tree重组，已经在[44,89,130]描述了通过==<u>仔细写入顺序</u>==，从而启用最小的日志记录。对于分区B-tree，批量插入后将向其追加新分区，也适用该技术合并分区B-tree的。

考虑批量插入一个表的带宽计算示例，该表包含一个主索引和三个二级索引，都存储在一个磁盘上，磁盘支持每秒200次读写操作（100个读写对）和100 MB/s读写带宽（假设是连续I/O，访问延迟可忽略不计）。 在示例计算中，主索引记录大小为1 KB，二级索引记录大小为0.02 KB，包括页面和记录标头的开销，以及空闲空间等。为简单起见，我们假设一个热缓冲池，只有叶节点需要I/O。**基准计划**依赖于随机插入4个索引，每个索引需要一次读取和一次写入操作。 每插入一行数据需要8次I/O，每秒可在此表中插入25行。每个磁盘驱动器插入的持续带宽为25×1 KB=25KBs = 0.025 MB/s。 这是插入的即时和持续带宽。

对于依赖索引删除和插入后重建索引的计划，假设索引删除几乎是即时的。 如果不存在索引，则即时插入带宽等于磁盘写入带宽。将表大小增加1%后，索引创建必须扫描插入数据量的**101**倍，然后将该数据量的**106％**写入索引的4个临时有序文件（在排序二级索引时共享临时有序文件），最后将它们合并到索引中：对于给定的添加数据量，I/O量为==**1 + 101×(1 + 3×1.06)=423**==，等于该量的423倍；在100 MB/s时，这允许100/423 MB/s = 0.236 MB/s的持续插入带宽。 虽然与100 MB/s相比这可能看起来很差，但它比随机插入快十倍，因此供应商推荐这种方案并不奇怪。

对于**在每个分支节点缓冲插入**的B-tree，假设每个节点中的缓冲区空间比节点中的子指针多插入10倍。==<u>溢出时的传播集中在具有最多未完成插入的子节点上；让我们假设平均可以传播20条记录</u>==。因此，每插入20条记录强制读写一个B-tree叶节点，或每个记录插入需要**1/20**的IO读写对。另一方面，具有缓冲区的B-tree节点要大得多，因此每个记录插入可能需要读写一个叶节点及其父节点，这种情况下插入每个记录强制**2/20=1/10** IO读写对。在包含一个主索引和三个二级索引（即总共4个B树）的示例表中，这些假设导致每个插入的记录有4/10的IO读写对。假定磁盘硬件每秒100对读写，因此支持每秒250条记录插入或0.250 MB/s的持续插入带宽。除了与以前的方法相比带宽略有改善外，此技术还保留和维护原始的B-tree索引，并允许在整个加载过程中进行查询处理。

在假定的磁盘硬件中，分区B-tree允许100MB/s的即时插入带宽，即，纯粹追加在内存工作空间排好序的新分区，排序算法是快排或是==**置换选择排序**==。优化B-tree，即合并分区B-tree中的一层，需要读取和写入分区，可以处理50MB/s（的插入数据）。如果**添加的分区达到主分区大小的33％时**调用重组，则添加给定数量的数据，需要相同数量的初始写入，加上此数量4倍的读取和写入以进行重组。对于单个B-tree，一次I/O放大9倍产生11MB/s的持续插入带宽。对于示例表，有主索引和三个二级索引，必须在所有索引之间划分该带宽，从而得到11 MB/s ÷(1 + 3×0.02) KB = 10 MB/s的持续插入带宽。这比其他**批量加载**技术快一个数量级。此外，在初始捕获新信息和B-tree重组期间，仍然可能处理查询。多层合并方案可以进一步增加该带宽，因为可以较少地重新组织主分区，但是现有分区的数量可以保持很小。

除了传统的数据库，B-tree索引也可以用于数据流。 **如果仅在索引中保留最近的数据项**，则需要批量插入技术和批量删除技术。 因此，索引流将在下一节中讨论。

- 批量插入的效率（也称为加载，滚入或信息捕获）对于数据库操作至关重要。
- 在某些实现中，维护索引的效率非常低，以至于在执行大型加载操作之前，索引会被删除。已经发布并实现了各种技术，以加速对B-tree索引的批量插入。它们的持续插入带宽相差几个数量级。

> ==TODO：==有哪些需要深入？

### 6.5 批量删除

批量删除（也称为清除，==**滚出**==或信息删除）可以采用一些用于批量插入的技术。 例如，一种删除技术只是使用最快的批量插入技术插入==**反物质**==（anti-matter）记录，留给查询或后续重组时删除，并回收存储空间。

分区B-tree允许在实际删除之前进行重组。 第一步（准备步骤），要删除的记录从主“源”分区移动到专用的“受害者”分区。 第二步（最后一步），非常高效地删除这个专用分区，主要是简单地释放叶节点，以及适当地修复B-tree的内部节点。请注意，第一步可以是增量的，完全只依赖于**系统事务**，并且可以在信息真正应该从数据库中消失之前运行。

> ==TODO：== Fig.6.7

图6.7显示了批量删除分区B-tree，第一步之后的中间状态。 要删除的B-tree数据已全部从主分区移动到单独的分区中，这样它们的实际删除只是释放整个叶节点，而不是删除分布在所有叶页中的单个记录。如果可以预期将来会有多个删除，例如，每日清除过时信息，则可以同时生成多个==**受害者**==分区。

可以有多种方式优化分区B-tree批量删除期间的日志量。第一，初始重组（“**un-merge**”）到一个或多个受害者分区，**<u>基于仔细写入顺序的合并</u>**的技术可以用到这。**第二**，将受害者分区写回数据库之后，可以在一个简短的日志记录中，描述将多个有效记录转换为幻影记录。**第三**，如前所述，如果合并删除和提交的日志记录，删除幻影时则不需要记录其内容。**第四**，释放整个B-tree节点（页面）可以采用类似技术，将分隔键转换为幻影记录。==<u>如果受害者分区太小，以至于它们可以保留在缓冲池中，直到最后删除为止，那么受害者分区中提交的删除页面允许将脏页写回源分区中</u>==。

批量插入和批量删除的技术一起实现了数据流的索引。数据流和近实时数据处理可受益于许多数据库技术，可能是经过调整的，==<u>例如从需求驱动的执行到数据驱动的执行</u>==[22]。然而，大多数流管理系统不提供流内容的持久化索引，因为原始或传统的索引维护技术会大大降低处理速度。

通过高带宽插入（附加内存中排好序的分区）、索引优化（合并有序文件）、分区拆分（按预定的删除日期）和删除（通过剪切整个分区），流上的B树索引甚至可以在永久存储上维护。例如，如果磁盘驱动器以100 MB/s的速度移动数据，则可以追加新数据，合并最近的分区，从主分区拆分即将过时的分区，并持续以约20 MB/s的速度切断真正过时的分区。如果初始或中间分区放置在特别有效的存储器上，例如闪存设备或非易失性RAM，或者如果设备排列在阵列中，则系统带宽可以高得多。

即使多个索引需要持续维护，具有多个独立索引的流也可以有效插入新数据并同时删除过时数据。 在这种情况下，同步所有必需的活动会产生一些开销。 尽管如此，（对于所有索引）也可以20 MB/s在示例磁盘驱动器上吸收和清除索引条目。

类似的技术可用在多层存储结构上分别占存数据。例如内存存储、闪存设备、性能优化的“企业”磁盘和容量优化的“消费者”磁盘。磁盘存储不仅在驱动器技术上有所不同，而且在冗余和故障恢复方法上也有所不同。例如，使用RAID-1“镜像”配置优化性能，而使用RAID-5“条带冗余”配置或RAID-6“双冗余”配置优化每个容量的成本。请注意，RAID-5和-6的每容量成本可以相等，因为后者可以承受双重故障，因此可以用于更大的磁盘阵列。

- 批量删除不如批量插入重要；尽管如此，各种优化可以按数量级影响带宽。
- 索引数据流需要批量插入和批量删除的技术。

### 6.6 碎片整理

文件系统中的碎片整理通常意味着将属于同一文件的块物理地放在一起；在数据库B-tree中，碎片整理还包含一些其他注意事项。这些注意事项适用于单个B-tree节点或页面，B-tree结构和分隔符键。 许多情况下，由于正常的工作负载处理，当一些或所有受影响的页面位于缓冲池中时，可以调用碎片整理逻辑，从而启动增量和在线碎片整理或重组[130]。

对于每个节点，碎片整理包括合并每个页面内空闲空间，以便将来高效地插入、删除幻影记录（除非当前被用户事务锁定），以及页内数据压缩的优化（例如，重复字段去重）。碎片整理可用来优化B-tree结构，以实现平衡的空间利用率（==**上面讨论创建B-tree中所述的可用空间**==）、更短的分隔键（后缀截断）和每页更好的前缀截断。

B-tree碎片整理可以按键顺序或在独立的键范围内进行，这也为并行性创造了机会。每个任务的==**键范围**==可以预先确定，也可以动态确定。例如，系统负载增加时，碎片整理任务可以立即提交、暂停并稍后恢复。请注意，碎片整理不会更改B-tree的内容，只更改其内部结构。因此，碎片整理任务不需要获取==**锁**==。当然，它必须获取**latch**来保护内存中的数据结构，如缓冲池中的页面。

在传统的B-tree结构中移动节点非常昂贵，有几个原因。首先，可以将页面内容从缓冲池中的一个**页帧**复制到另一个**页帧**，虽然这样做成本适中，但是“重命名”缓冲区页面可能更快，即，为==**新旧页面位置**==分配**缓冲区描述符**，并锁定之，然后将页帧从一个描述符传输到另一个描述符。因此，页面在缓冲池中应该“按引用”而不是“按值”迁移。如果每个页面包含其预期的磁盘位置，以帮助数据库进行一致性检查，则此时必须更新此字段。==<u>如果可以在缓冲池中保留被释放的页，例如，在创建、写入、读取和删除临时表之后，这个优化的缓冲区操作，必须首先从缓冲区的哈希表中删除任何有新页标识符的先前页。或者，两个缓冲区描述符可以简单地交换它们的两个页面帧</u>==。

第二，移动一个页面可能很昂贵，因为每个B-tree节点都参与到**一个指针网络**。移动叶节点时，必须更新父节点以及前面和后面的（兄弟）叶节点。因此，所有三个周围的页面都必须存在于缓冲池中，恢复日志中要有它们的更改记录，在下一个检查点之前或期间，把修改后的页面写回磁盘。同时移动多个叶子节点通常是有利的，这样只读写每个叶子页一次。尽管如此，每个单页移动操作可以是单个**系统事务**，用于分配信息（例如，分配位图）和用于重组索引的锁，可以被频繁地释放。

如果每层的B-tree节点没有通过物理页标识符形成链，即，如果每个B-tree节点仅由其父节点而不是相邻节点指向，则迁移页和碎片整理的成本要低得多。具体来说，只有B-tree节点的父节点在页面移动时需要更新。它的兄弟和子节点都不受影响；页面迁移期间，不需要它们在内存中，也不需要I/O、修改或记录日志等。

第三，页面迁移可能非常昂贵原因是日志记录，即恢复日志的写入数据量。碎片整理期间，”完整记录“页面迁移的标准方法是，作为分配和格式化新页面的一部分来记录页面内容。从系统崩溃或介质故障中进行恢复时，与所有分配的其他页面一样，无条件地将日志记录中的页面内容复制到磁盘上的页面。

然而，记录整个页面的内容只是使迁移持久的几种方法之一。第二种“强制写入”方法是使用小日志记录来记录迁移本身，即包含新旧页位置，但不包含页内容，并在提交页面迁移之前将数据页强制到磁盘的新位置。事务处理提交之前强制更新数据页到磁盘，在日志记录和恢复的理论和实践中得到了很好的证实[67]。从系统崩溃中恢复，可以安全地假设提交的迁移已保存在磁盘上。另一方面，**媒介恢复**必须重复页面迁移，之所以能这样做，因为在基于日志**redo**期间，旧页面位置在此刻仍包含正确的内容。这同样适用于日志传送和数据库镜像，为即时故障转移做好准备的技术：即通过从主站点连续传送恢复日志，并在辅助（备份）站点上连续redo日志来恢复，以保证备份（通常是远程）数据库为最新。

最雄心勃勃，最有效的碎片整理方法，既不记录页面内容也不强制它到磁盘的新位置。相反，这种“未记录”的页面迁移依赖于旧页面位置来保留一个页面映像，可以根据该映像进行恢复。在系统恢复期间，检查旧页位置，如果它包含的日志序列号低于**迁移日志记录**，则必须重复迁移，即在将旧页恢复到迁移时，必须在缓冲池中重新命名该页，然后才能将其他日志记录应用到新页。为了保证从故障中恢复的能力，有必要在旧位置保留旧页面映像，直到将新页面映像写入新位置。即使在迁移事务提交后，一个单独的事务因为新的原因分配旧位置，在成功地将迁移的页写入新位置之前，不能在磁盘上覆盖旧位置。因此如果在恢复时，系统在旧页位置中找到新的日志序列号，则可以安全地假定迁移的页内容在新位置可用，并且不需要进一步的恢复操作。

除了众所周知的先写日志的写依赖性之外，一些可恢复B-tree的维护方法已经在缓冲池中的数据页之间使用了这种**写依赖性**。要使用标准技术实现这种依赖关系，必须在缓冲区管理器中表示旧页和新页。与通常的写依赖项情况不同，迁移事务可能会将旧位置标记为清除（**clean**），即不需要将任何内容写回磁盘上的旧位置。==<u>请注意，redo迁移事务必须重新创建此写依赖项，例如在媒介恢复和日志传送中</u>==。

第三种方法的潜在弱点是备份和还原操作，特别是当“在线”备份时，即系统正在积极处理用户事务，并且备份不包含整个数据库，而是只包含当前分配给某些表或索引的页。此外，备份过程和页面迁移的详细操作必须以一种特别不幸的方式交错进行。在这种情况下，备份可能不包括旧位置的页面映像，因为它已被释放。因此，当备份日志以补充在线数据库备份时，必须通过新页面映像补充迁移事务。==<u>实际上，在线数据库备份及其相应的还原操作中，日志记录和恢复行为实际上**从不记录的页迁移**更改为**完全记录的页迁移**</u>==。在还原操作期间应用此日志必须读取添加到迁移日志记录的页面内容，并将其写入新位置。如果页面还反映了页面迁移后发生的后续更改，则由于页面上的日志序列号，恢复将正确处理这些更改。同样，这与现有机制非常相似，在这种情况下，一些商业数据库管理系统支持==**“无日志记录”创建索引**==的备份和恢复。

当迁移事务将页面从旧位置移动到新位置时，用户事务可以持有B-tree节点内键上的**锁**。但任何这样的用户事务都==<u>必须重新搜索B-tree节点</u>==，并通过从B-tree根到叶的新搜索，以便获得新的页面标识符，并在日志中正确记录进一步的内容更改（如果有）。这与B-tree节点的拆分和合并操作非常相似，这也会使用户事务可能临时保留的页面标识符知识失效。最后，如果一个用户事务必须回滚，那么它必须补偿它在新位置的操作，同样地这非常类似与，==<u>不同的事 务拆分或合并了B-tree节点之后补偿用户事务</u>==。

- B-tree的大多数实现（与其他存储结构一样）需要偶尔进行碎片整理（重组）以确保连续性（在扫描期间减少搜索），可用空间等。
- 通过使用**fence键**而不是相邻节点的指针（参见第3.5和4.4节）以及仔细的写入顺序（参见第4.10节），可以降低页面移动的成本。
- 碎片整理（重组，压缩）可以在许多**轻量级**的系统事务中进行，可以“先暂停再恢复”而不会浪费工作。

### 6.7 索引验证

显然，有各种各样的技术，用于B-tree索引的高效数据结构和算法。 当更多的技术被发明或在一个特定的软件系统中实现时，会发生遗漏或错误，必须找到它们。其中大多数错误都表现在不满足数据结构预期的**不变式**。因此，作为软件开发和改进过程中严格回归测试的一部分，对B-tree的验证至关重要。

许多遗漏和错误出现在大型B-tree，大规模更新和大负载查询的场景下，因此需要频繁验证，以便在软件开发期间及时发现。这样，效率在B-tree验证中很重要。

可以肯定的是，部署后还需要验证B-tree。众所周知，DRAM，闪存设备和磁盘设备会出现硬件缺陷[114]。 软件缺陷不仅可以在数据库管理系统中找到，还可以在设备驱动程序，文件系统代码等中找到[5,61]。虽然在许多硬件和软件层中存在一些自检，但数据库管理系统的供应商建议定期验证数据库。 验证备份媒介也很有价值，因为它增强了对媒介及其内容的信任和信心，如果应该永远都需要。

> ==TODO：==原文这里的should they ever be needed是啥语法？

例如，Mohan描述了由于SCSI标准实现中的性能优化而导致部分写入的危险[94]。 他的重点是使用适当的页面修改，每次读取操作后的页面验证，日志记录，日志分析，恢复逻辑等来预防问题。这些技术的复杂性，加上对这些性能关键模块的持续改进的需要，强化了我们的信念，即B-tree结构的完整、可靠和有效验证是必需的防御措施。

> ==TODO：== Fig.6.8

例如，图6.8显示了错误拆分叶节点的结果。当叶节点b被分裂并且叶节点c被创建时，后继节点d中的后向指针错误地保持不变。随后，叶节点的（降序）扫描将产生错误的查询结果，进一步，拆分和合并操作将造成更严重的破坏。可能出现问题的情况：不完整的执行、不完整的恢复、或分裂操作不完整的复制。原因可能是数据库软件（例如缓冲池管理）或存储管理软件（例如快照或版本管理）中的缺陷。换句话说，有成千上万行的代码可能导致类似于图6.8所示情况的缺陷。

由于B-tree是复杂的数据结构，因此长期以来难以有效地验证所有不变式，包括页内不变式，父子指针和邻居指针以及键关系，即叶节点中分隔键和键的正确顺序。后一个问题不仅涉及父子节点关系，还涉及所有祖先 - 后代关系。后一个问题不仅与亲子关系有关，而且与所有祖先-后代关系有关。例如，B-tree根节点中的分隔键不仅必须对根的直接子节点中的键进行排序，而且必须对B-tree所有层级的键进行排序，直至将排到叶节点上。与多个B-tree相关的不变式，通常可以使用适当的关联来处理，例如表的主索引及其二级索引，或物化视图和其基础表和视图。如果将数据库验证的所有方面按查询处理建模，那么从资源管理到并行执行，可以利用许多查询处理技术。

一旦页面在缓冲池中，就很容易验证页内不变式，但是详尽的验证需要检查所有不变式的所有实例，例如，所有相邻叶节点之间的键范围关系。通过整个键范围内的索引顺序扫描，可以轻松验证跨页不变式。但是，如果由于并行执行或备份介质（如磁带）的限制而不能做索引顺序扫描，则可以使用基于聚合的算法验证结构不变式。当以任何顺序扫描B-tree页面时，从每个页面提取所需信息并与其他页面的信息匹配。例如，如果页面x将页面y命名为其后继者，则页面y将页面x命名为其前身，则**邻居指针**匹配。键值范围必须包含在提取的信息中，以确保键值范围不相交，并由相应祖先节点中的分隔键正确区分。并由相应祖先节点中的分隔键正确区分。如果B-tree中的最低公共祖先在更高的位置，并且如果要避免传递操作，则必须在B-tree节点中保留一些附加信息。

> ==TODO：== Fig.6.9

图6.9显示了一个B-tree，及其相邻叶节点，即表亲节点*d*和*e*，没有共享的父节点，而是共享祖父节点。阴影区域代表记录及其键；如果它们的阴影不同（相等），则两个键也不同（相等）。在传统的B-tree实现中，并没有立即或明显的有效解决方案，来高效地验证子节点*d*和*e*之间的键和指针。==**潜在的问题是，没有简单的方法验证叶节点*d*中所有的键确实比根节点*a*中的分隔键小，并且叶节点*e*中所有的键确实比根节点a中的分隔键大**==。邻居（*b−c*和*d−e*）之间以及父母与子女之间正确的键关系（*a−b, a−c, b−d, c−e*）并不能保证跳过层级之间正确的键关系（*a−d, a−e*）。


> ==TODO：== Fig.6.10

图6.10显示了**fence键**，为B-tree验证表亲问题提供了简单的解决方案，即使**fence键**最初是由写优化的B-tree引入[44]。与传统B-tree设计的本质区别在于，页面分裂不仅将分隔键发布到父页面，而且还将此分隔键的副本保留为两个分裂后兄弟页面中高和低的“**fence键**”。请注意，由于前缀和后缀截断，分隔符和**fence键**可能非常短[10]。这些**fence键**扮演兄弟指针的角色，用搜索键替换传统的页面标识符。除了父节点中的子指针，**fence键**消除了页面移动时必须更新的其它页面标识符，从而加速了碎片整理。**fence键**也有助于键范围锁定，因为它们是可以锁定的键值。在这个意义上，它们类似于传统的幻影记录，除了**fence键**不受幻影清理过程影响。

这里的重要好处是简化了验证过程，并且可以很容易地在多层的B-tree中，解决表亲问题，包括“第二个表亲”、“第三个表亲”等。在图6.10中，下面四对事实可以由水平阴影标记的键派生出来，每对事实从两页独立得出。

  1. 从页*a*得到的事实是，b是层1的节点，是其右边的**fence键**（上界）。
  2. 从页*a*得到的事实是，c是层1的节点，是其左边的**fence键**（下界）。
  3. 从页*b*得到的事实是，b是层1的节点，是其右边的**fence键**（上界）；这与上面的事实1相匹配。
  4. 从页*b*得到的事实是，d是叶节点，是其右边的**fence键**（上界）。
  5. 从页*c*得到的事实是，c是层1的节点，是其左边的**fence键**（下界）；这与上面的事实2相匹配。
  6.  从页*c*得到的事实是，e是叶节点，是其左边的**fence键**（下界）。
  7. 从页*d*得到的事实是，d是叶节点，是其右边的**fence键**（上界）；这与上面的事实4相匹配。
  8. 从页*e*得到的事实是，e是叶节点，是其左边的**fence键**（下界）；这与上面的事实6相匹配。

表亲页d和e之间不需要匹配。由于其他比较之间的传递性，它们的**fence键**是相等的。事实上，从页*d*和*e*导出的匹配事实不能包括页面标识符，因为这些页不携带其他页的标识符。最好的情况是，可以推导出以下事实，尽管它们是由上述事实暗示的，因此对B-tree质量的验证没有贡献：

  9.  从页*b*得到的事实，层1的节点有一个特定的**fence键**（上界）。
  10. 从页*c*得到的事实，层1的节点有一个特定的**fence键**（下界）；匹配上面的事实9。
  11. 从页*d*得到的事实，叶节点有一个特定的**fence键**（上界）。
  12. 从页*e*得到的事实，叶节点有一个特定的**fence键**（下界）；匹配上面的事实11。

根的分隔键沿着相邻节点的整个接缝一直复制到叶级。沿着整个接缝检查相等性和一致性，并通过传递性检查接缝。因此，**fence键**也解决了多层B-tree中的第二和第三表亲等问题。

这些事实可以按任何顺序得出；因此，B-tree验证可以按磁盘序扫描，甚至从备份介质中读取数据库页面。 可以使用内存中的哈希表（并且可能是哈希表溢出到磁盘，存为分区文件）来匹配这些事实，或者使用位图。 前一种方法需要更多的内存和更多的CPU工作，但可以立即识别任何错误；后一种方法更快，需要更少的内存，但如果某些事实不能匹配与从其他页派生、本应相等的事实，则需要对数据库进行第二次传递。此外，==<u>位图方法有很小的概率无法检测到相互掩盖的两个错误</u>==。

Fence keys also extend local online verification techniques [80]. In traditional systems, neighbor pointers can be verified during a root-to-leaf navigation only for siblings but not for cousins, because the identity of siblings is known from information in the shared parent node but verification of a cousin pointer would require an I/O operation to fetch the cousin’s parent node (also its grandparent node for a second cousin, etc.). Thus, earlier techniques [80] cannot verify all correctness constraints in a B-tree, no matter how many search operations per-form verification. Fence keys, on the other hand, are equal along entire B-tree seams, from leaf level to the ancestor node where the key value serves as separator key. A fence key value can be exploited for online verification at each level in a B-tree, and an ordinary root-to-leaf B-tree descent during query and update processing can verify not only siblings with a shared parent but also cousins, second cousins, etc. Two search operations for keys in neighboring leaves verify all B-tree constraints, even if the leaves are cousin nodes, and search operations touching all leaf nodes verify all correctness constraints in the entire B-tree.

围栏键还扩展了本地在线验证技术[80]。在传统系统中，可以在根到叶导航期间仅针对兄弟姐妹而不是堂兄弟来验证邻居指针，因为兄弟姐妹的身份是从共享父节点中的信息中得知的，但是表兄指针的验证将需要I / O获取表兄弟的父节点（也是第二个堂兄的祖父节点等）的操作。因此，无论每种形式的验证有多少搜索操作，早期的技术[80]都无法验证B树中的所有正确性约束。另一方面，围栏键沿着整个B树接缝是相等的，从叶级到祖先节点，其中键值用作分隔符键。可以利用围栏键值在B树中的每个级别进行在线验证，并且在查询和更新处理期间普通的根对叶B树下降不仅可以验证具有共享父级的兄弟姐妹，还可以验证兄弟姐妹，第二相邻叶子中的密钥的两个搜索操作验证所有B树约束，即使叶子是表亲节点，并且触摸所有叶子节点的搜索操作验证整个B树中的所有正确性约束。

围栏密钥还扩展了本地在线验证技术[80]。在传统的系统中，邻居指针只能在根到叶导航期间为兄弟姐妹而不是兄弟姐妹进行验证，因为兄弟姐妹的身份是从共享父节点中的信息中知道的，但是对兄弟姐妹指针的验证将需要I/O操作来获取sin的父节点（也是第二个表亲的父节点等）。因此，早期的技术[80]无法验证B树中的所有正确性约束，无论每个表单验证有多少搜索操作。另一方面，从叶级到键值用作分隔键的祖先节点，栅栏键沿整个B树接缝相等。在一个B树中，可以利用一个篱笆键值在每一级进行在线验证，在查询和更新处理过程中，一个普通的根到叶的B树下降不仅可以验证具有共享父代的兄弟姐妹，还可以验证表兄弟姐妹、第二个表兄弟姐妹等。相邻的两个键搜索操作leaves验证所有的B-树约束，即使leaves是表亲节点，并且触摸所有leave节点的搜索操作验证整个B-树中的所有正确性约束。

For example, two root-to-leaf searches in the index shown in Figure 6.10 may end in leaf nodes *d*and *e*. Assume that these two root-to-leaf passes occur in separate transactions. Those two searches can verify correct fence keys along the entire seam. In the B-tree that employs neighbor pointers rather than fence keys as shown in Figure 6.9, the same two root-to-leaf searches could verify that entries in leaf nodes*d*and *e*are indeed smaller and larger than the separator key in the root node but they cannot verify that the pointers between cousin nodes *d*and *e*are mutual and consistent.

B-tree verification by extracting and matching facts applies not only to traditional B-trees but also to B^link^-trees and their transitional states. Immediately after a node split, the parent node is not yet updated in B^link^-tree and thus generates the facts as above. The newly allocated page is a normal page and also generates the facts as above. The page recently split is the only one with special information, namely a neighbor pointer. Thus, a page with a neighbor pointer indicating a recent split not yet reflected in the parent must trigger derivation of some special facts. Since this old node provides the appropriate “parent facts” for the new node, the old node could be called a “foster parent” if one wants to continue the metaphor of parent, child, ancestor, etc.

> ==TODO：== Fig.6.11

Figure 6.11 illustrates such a case, with node *b*recently split. The fact about the low fence key of node *d*cannot be derived from the (future) parent node *a*. The fact derived from node *d*must be matched by a fact derived from node *b*. Thus, node *b*acts like a temporary parent for the new node *d*not only in terms of the search logic but also during verification of the B-tree structure. Note that the intermediate state in Figure 6.11 could also be used during node removal from a B-tree, again with the ability to perform complete and correct B-tree verification at any time, in any sequence of nodes, and thus on any media.

In addition to verification of a B-tree structure, each individual page must be verified prior to extraction of facts, and multiple B-tree indexes may need to be matched against one another, e.g., a secondary index against the appropriate identifier in the primary index. In-page verification is fairly straightforward, although it might be surprising how many details are worth validating. Matching multiple indexes against one another is very similar to a join operation and all standard join algorithms can be employed. Alternatively, a bitmap can be used, with a miniscule probability of two errors masking each other and with a second pass required if the bitmap indicates that an error exists.

> Automatic repair of B-tree indexes is not well studied. Techniques may rely on dropping and rebuilding an entire index, replaying the recovery log for just one page, or adjusting a page to match its related pages. A systematic study of repair algorithms, their capabilities, and their performance would be useful for the entire industry.

B-tree索引的自动修复还没有得到很好的研究。技术上可能依赖于删除和重建整个索引、仅为一个页面重做恢复日志或调整页面以匹配其相关页面。系统研究修复算法、它们的能力和性能将对整个行业有用。

- B-tree索引的验证可防止软件和硬件故障。 所有商业数据库系统都提供此类工具
- 可以通过单个索引顺序扫描来验证B-tree，由于碎片化因而代价可能高昂。
- 基于磁盘顺序扫描的验证需要汇总从页面提取的事实。位向量过滤器可以加速该过程，但是如果发现不一致，则不能精确地识别不一致性（由于可能的散列冲突）。
- 如果节点携带**fence键**而不是**邻居指针**，则查询执行（作为副作用）可以验证B-tree所有的不变式。

### 6.8 小结

总之，B-tree实用工具在数据库系统的可用性和**总体拥有成本中**起着重要的作用。B-tree在索引结构中是唯一的，因为有许多众所周知的高效实用技术，且被广泛应用。新提议索引结构的性能和可伸缩性必须能与B-tree竞争，不仅包括查询处理和更新方面的竞争，还包括从索引创建到碎片整理和索引验证的实用工具操作方面的竞争。