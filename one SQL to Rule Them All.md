



| E                                                            | C                                                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 第三章 **MINIMAL STREAMING SQL FOUNDATIONS**                 |                                                              |
| Our proposal for streaming SQL comes in two parts. **The first, in this section, is conceptual groundwork, laying out concepts and implementation techniques that support the fundamentals of streaming operations**. <u>The second, in Section 6, builds on these foundations, identifies the ways in which standard SQL already supports streaming, and proposes minimal extensions to SQL to provide robust support for the remaining concepts</u>. The intervening sections are dedicated to discussing the foundations through examples and lessons learned from our open source frameworks. | 我们对流式SQL的建议分为两部分。**在本节中，第一部分是概念的铺垫，阐述支持流操作基本原理的概念和实现技术**。<u>第二部分，在第6节中，基于这些基础，确定了标准SQL已经支持流的方式，并提出了对SQL的最小扩展，以提供对剩余概念的强大支持</u>。中间的部分专门通过示例和从我们开源框架中汲取的经验教训来讨论基础。 |
| *3.1 Time-Varying Relations*                                 |                                                              |
| In the context of streaming, the key additional dimension to consider is that of time. <u>When dealing with classic relations, one deals with relations at a single point in time</u>. **When dealing with streaming relations, one must deal with relations as they evolve over time**. *==We propose making it explicit that SQL operates over time-varying relations, or TVRs==*. | 在流的上下文中，额外需要考虑的最终的维度是时间。<u>在处理传统关系时，只是在一个时间点处理关系</u>。 **处理流式关系时，必须处理随着时间变化而变化的关系**。==我们建议明确指出SQL在时变关系或TVR上运行==。 |
| **A time-varying relation is exactly what the name implies: a relation whose contents may vary over time. The idea is compatible with the mutable database tables with which we are already familiar; to a consumer of such a table, it is already a time-varying relation(<u>And indeed, the `AS OF SYSTEM TIME` construct already enshrines the concept of a time-varying relation in the SQL standard</u>).** <u>But such a consumer is explicitly denied the ability to observe or compute ==based on how the relation changes over time==</u>. A traditional SQL query or view can express a derived time-varying relation that evolves in lock step with its inputs: at every point in time, it is equivalent to querying its inputs at exactly that point in time. But there exist TVRs that cannot be expressed in this way, where time itself is a critical input. | **时变关系正是该名称所隐含的含义：其内容可能随时间而变化的关系。这个想法与我们已经熟悉的可变数据库表是兼容的；对于这样一个表的使用者来说，表已经是一个时变关系（<u>实际上，`AS OF SYSTEM TIME`构造已经包含了SQL标准中时变关系的概念</u>）**。<u>但是，此类使用者没有能力==基于关系如何随时间变化==来进行观察或计算</u>。传统的SQL查询或视图可以表示派生的时变关系，该关系随输入的变化而逐步演化：在每个时间点，它都相当于在该时间点查询其输入。但是存在着不能以这种方式表达的TVR，其中时间本身是至关重要的输入。 |
| TVRs are not a new idea; they are explored in [8, 9, 33]. <u>An important aspect of TVRs is that they may be encoded or materialized in many ways, notably as a sequence of **classic relations** (instantaneous relations, in the CQL parlance), or as a sequence of INSERT and DELETE operations</u>. ==These two encodings are duals of one another, and correspond to the tables and streams well described by Sax et al. [33]==. There are other useful encodings based on relation column properties. For example, when an aggregation is **invertible**, a TVR’s encoding may use aggregation differences rather than entire deletes and additions. | TVR并不是一个新概念，在[8，9，33]中有对它们的探讨。<u>TVR的一个重要方面是，可以用多种方式编码或物化它们，特别是作为**经典关系**的序列（用CQL术语来说，瞬时关系），或作为`INSERT`和`DELETE`操作的序列</u>。==这两种编码是彼此的对偶，对应于Sax等人描述的表和流。[33]==。还有其他基于关系列属性的有用编码。例如当聚合**可逆**时，可以使用聚合差异编码TVR，而不是编码为删除和添加。 |
| Our main contribution regarding TVRs is to suggest that neither the CQL nor the Streams and Tables approaches go far enough: rather than defining the duality of streams and tables and then proceeding to treat the two as largely different, we should use that duality to our advantage. The key insight, stated but under-utilized in prior work, is that streams and tables are two representations for one semantic object. This is not to say that the representation itself is not interesting \- there are use cases for materializing and operating on the stream of changes itself - but this is again a TVR and can be treated uniformly. |                                                              |
| What’s important here is that the core semantic object for relations over time is always the TVR, which by definition supports the entire suite of relational operators, even in scenarios involving streaming data. This is critical, because it means anyone who understands enough SQL to solve a problem in a non-streaming context still has the knowledge required to solve the problem in a streaming context as well. |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
| As described in [33], stream changelogs are a space-efficient way of describing the evolution of a TVR over time. Changelogs capture the element-by element differences between two versions of a relation, in effect encoding the sequence of INSERT and DELETE statements used to mutate the relation over time. They also expose metadata about the evolution of the rows in the relation over time. For example: which rows are added or retracted, the processing time at which a row was materialized, and the revision index of a row for a given event-time interval | 如[33]所述，**流变化**日志是描述TVR随时间演变的一种节省空间的方式。**变更日志**捕获**两个版本relation**之间每个元素的差异，实际上编码了用于随时间改变关系的`INSERT`和`DELETE`语句的序列。它们还公开了关系中行随时间演变的元数据。==例如：添加或收回哪些行，**物化**行的处理时间，以及给定**事件时间间隔**的行的修订索引==。 |
| If dealing exclusively in TVRs, as recommended above, rendering a changelog stream of a TVR is primarily needed when materializing a stream-oriented view of that TVR for storage, transmission, or introspection (in particular, for inspecting metadata about the stream such as whether a change was additive or retractive). Unlike other approaches which treat stream changelogs as wholly different objects from relations (and the primary construct for dealing with relations over time), we propose representing the changelog as simply another time-varying relation. In that way, it can be operated on using the same machinery as a normal relation. Furthermore, it remains possible to declaratively convert the changelog stream view back into the original TVR using standard SQL (no special operators needed), while also supporting the materialization delays described next. | <u>如果按照上述建议专门处理TVR，则在实现该TVR的面向流的视图以进行存储，传输或自省（尤其是检查有关流的元数据，例如是否 变化是累加的或回缩的）。与将流变更日志视为与关系完全不同的对象（以及随时间推移处理关系的主要结构）的其他方法不同，</u>**我们建议将变更日志简单地表示为另一个时变关系**。 这样，可以使用与正常relation相同的机制来操作它。 此外，仍然可以使用标准SQL（无需特殊运算符）以声明方式将**changelog流视图**转换回原始TVR，同时还支持以下所述的实现延迟。 |
| **第5章**                                                    |                                                              |
| **Some operations only work (efficiently) on watermarked event time attributes.** Whether performing an aggregation on behalf of the user or executing <u>overtly</u> stateful business logic, an implementer must have a way to maintain finite state over infinite input. Event time semantics, particularly watermarks, are critical. State for an ongoing aggregation or stateful operator can be freed when the watermark is sufficiently advanced that the state won’t be accessed again. | 某些操作仅对带水位的事件时间属性起作用（有效）。无论是代表用户执行聚合还是执行<u>公开的</u>有状态业务逻辑，实现者都必须有一种方法在无限输入上保持有限状态。**事件时间语义**（尤其是水位）至关重要。 ==**当水位足够领先**==，因而不会再访问该状态时，**可释放**正在进行的聚合或状态运算符的状态。 |
| **Operators may erase watermark alignment of event time attributes.** Event time processing requires that event timestamps are aligned with watermarks. Since event timestamps are exposed as regular attributes, they can be referenced in arbitrary expressions. Depending on the expression, the result may or may not remain aligned with the watermarks; these cases need to be taken into account during query planning. In some cases it is possible to preserve watermark alignment by adjusting the watermarks, and in others an event time attribute loses its special property. | **==运算符可以删除事件时间属性的水位对齐方式==**。==<u>事件时间处理要求事件时间戳与水位对齐</u>==。由于事件时间戳是作为常规属性公开的，因此可以在任意表达式中引用它们。 根据表达式的不同，结果可能与水位保持一致，也可能不与水位保持一致，在查询规划期间需要考虑这些情况。在某些情况下，可以通过调整水位来保持水位对齐，而在其他情况下，事件时间属性会失去其特殊属性。 |
| **Time-varying relations might have more than one event time attribute.** Most stream processing systems that feature event time processing only support a single event time attribute with watermarks. When joining two TVRs it can happen that the event time attributes of both input TVRs are preserved in the resulting TVR. One approach to address this situation is to "hold-back" the watermark such that all event time attributes remain aligned. | **时变关系可能有多个事件时间属性**。大多数具有事件时间处理功能的流处理系统**==只支持带有水位的单个事件时间属性==**。当`join`两个**TVR**时，两个输入TVR的<u>事件时间属性</u>可能会保留在结果TVR中。解决这种情况的一种方法是**”抑制“**水位，以便所有事件时间属性保持对齐。 |
| **Reasoning about what can be done with an event time attribute can be difficult for users.** <u>In order to define a query that can be efficiently executed using event time semantics and reasoning, event time attributes need to be used at specific positions in certain clauses, for instance as an ORDER BY attribute in an OVER clause.</u> ==These positions are not always easy to spot and failing to use event time attributes correctly easily leads to very expensive execution plans with undesirable semantics.== | **对于用户来说，很难对事件时间属性进行推理**。为了定义可以使用事件时间语义高效执行、并能有效推理事件时间的查询，需要在某些子句中的特定位置使用事件时间属性，例如在`OVER`子句中`ORDER BY`属性。==这些位置并不总是很容易被发现，如果不能正确地使用事件时间属性，很容易导致代价高昂的执行计划和不需要的语义==。 |
| **Reasoning about the size of query state is sometimes a necessary ==evil==**. Ideally, users should not need to worry about internals when using SQL. However, when consuming unbounded input user ==<u>intervention</u>== is useful or sometimes necessary. So we need to consider what metadata the user needs to provide (active interval for attribute inserts or updates, e.g. sessionId) and also how to give the user feedback about the state being consumed, relating the physical computation back to their query. | **对查询状态的大小进行推理有时是==必不可少==的**。理想情况下，用户在使用sql时不必担心内部问题。然而，当使用无限输入时，用户<u>==干预==</u>是有用的，有时是必要的。因此，我们需要考虑用户需要提供哪些元数据（属性插入或更新的活动间隔，例如`sessionId`），以及如何向用户反馈正在使用的状态，从而将物理计算与其查询联系起来。 |
| **It is useful for users to distinguish between streaming and materializing operators**. In Flink and Beam, users need to reason explicitly about which operators may produce updating results, which operators can consume updating results, and the effect of operators on event time attributes. These low-level considerations are inappropriate for SQL and have no natural place in relational semantics; we need materialization control extensions that work well with SQL. | **对于用户来说，区分==流运算符==和==物化运算符==非常有用**。 在***Flink***和***Beam***中，用户需要明确推断出**哪些运算符可以产生更新结果**，**哪些运算符可以消耗更新结果**以及**运算符对事件时间属性的影响**。这些底层考虑不适用于SQL，且在relation的语义中没有自然的位置；我们需要与SQL配合使用的**==物化控制扩展==**。 |
| **Torrents of updates**: For a high-throughput stream, it is very expensive to issue updates continually for all derived values. Through materialization controls in Flink and Beam, this can be limited to fewer and more relevant updates. | **更新洪流**：对于高吞吐量流，<u>==连续发布所有派生值的更新非常昂贵==</u>。 通过Flink和Beam中的**==物化控制==**，将其限制为较少、且更相关的更新。 |
| **6.1** Existing Support for Streaming in SQL                |                                                              |
| **Queries are on table snapshots**: As a classical SQL table evolves, queries can execute on their current contents. In this way, SQL already plays nicely with relations over time, albeit only in the context of static snapshots. | **==快照表==上的查询**：随着经典SQL表的演进，查询可以在其当前内容上执行。 这样，尽管只是在静态快照的上下文中，SQL仍然可以很好地处理各种*relation*。 |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
| **6.3** Grouping on Event Timestamps                         |                                                              |
| ==When processing over an unbounded stream, an aggregate projected in a query of the form `SELECT ... GROUP BY ...` is complete when it is known that no more rows will contribute to the aggregate.== Without extensions, it is never known whether there may be more inputs that contribute to a grouping. Under event time semantics, the watermark gives a measure of completeness and can determine when a grouping is complete based on event time columns. This corresponds to the now-widespread notion of event-time windowing. We can adapt this to SQL by leveraging event time columns and watermarks. | 在无限制的流上进行处理时，当已知没有更多行将对聚合起作用时，以`SELECT ... GROUP BY ...`格式查询的投影聚合就完成了。 |
| **Extension 2 (Grouping on event timestamps).** When a `GROUP BY` clause contains a grouping key that is an event time column, any grouping where the key is less than the watermark for that column is declared complete, and further inputs that would contribute to that group are dropped (in practice, a configurable amount of allowed lateness is often needed, but such a mechanism is beyond the scope of this paper; for more details see Chapter 2 of [6]) ==Every `GROUP BY` clause with an unbounded input is required to include at least one event-time column as a grouping key.== | 每个具有**无界输入**的`GROUP BY`子句都必须包括至少一个**事件时间列**作为分组键。 |
| **6.4** Event-Time Windowing Functions                       |                                                              |
| It is rare to group by an event time column that contains original event timestamps unless you are trying to find simultaneous events. Instead, event timestamps are usually mapped to a distinguished end time after which the grouping is completed. In the example from Section 4, bid timestamps are mapped to the end of the ten minute interval that contains them.We propose adding built-in table-valued functions that augment a relation with additional event timestamp columns for these common use cases (while leaving the door open for additional built-in or custom TVFs in the future). | 除非尝试查找同时发生的事件，否则很少按包含**原始事件时间戳**的**事件时间列**进行分组。**相反**，通常将<u>事件时间戳</u>映射到<u>可区分的结束时间</u>，在此之后完成分组。在第4节的示例中，==**出价时间戳**映射到包含它们的十分钟间隔的末尾==。我们建议添加内置的**table-valued**函数处理这些常见用例，通过<u>增加事件时间戳列以增强relation</u>（同时为将来增加其他内置函数，或自定义TVF敞开门）。 |
| **Extension 3 (Event-time windowing functions).** Add (as a starting point) built-in table-valued functions Tumble and Hop which take a relation and event time column descriptor as input and return a relation with additional event-time interval columns as output, and establish a convention for the eventtime interval column names. | 扩展3（事件时间窗口功能）。（作为起点）添加内置的**table-valued**函数`Tumble`和`Hop`，将**relation**和**事件时间列描述符**作为输入，输出的relation，带有额外的**事件时间间隔列**，并为**事件时间间隔列名**建立约定。 |
|                                                              |                                                              |
| **6.5** Materialization Controls<br>6.5.1 *Stream Materialization* |                                                              |
| **Extension 4 (Stream Materialization)**. EMIT STREAM results in a time-varying relation representing changes to the classical result of the query. In addition to the schema of the classical result, the change stream includes columns indicating: whether or not the row is a retraction of a previous row, the changelog processing time offset of the row, **a sequence number relative to other changes to** the same event time grouping. | **Extension 4 (Stream Materialization)**：EMIT STREAM以**时变关系**表示对查询的经典结果的**变更**。除了查询结果的***schema***之外，**变更流**还包括一些列，这些列指示：该行是否是前一行的撤回、该行变更日志的**处理时间偏移量**、相对于同一**事件时间分组**的其他更改的序列号的列。 |
| As far as equaling the output of the original CQL query, the STREAM keyword is a step in the right direction, but it’s clearly more verbose, capturing the full evolution of the highest bidders for the given 10-minute event time windows as data arrive, whereas the CQL version provided only a single answer per 10-minute window once the input data for that window was complete. To tune the stream output to match the behavior of CQL (but accommodating out-of-order input data), we need to support materialization delay. | 就等于原始CQL查询的输出而言，STREAM关键字是朝着正确方向迈出的一步，但它显然更加冗长。数据到达时，在给定的10分钟**事件时间窗口**内，捕获最高出价者的全部演变情况。而CQL版本在该窗口的输入数据完整后，每10分钟仅提供一个答案。为了调整流输出以匹配CQL的行为（但要容纳乱序的输入数据），我们需要支持**物化延迟**。 |
| 6.5.2 *Materialization Delay*                                |                                                              |
| *Completeness delays*: Event time windowing provides a means for slicing an **==unbounded relation==** into finite temporal chunks, and for use cases where **==eventual consistency of windowed aggregates==** is sufficient, no further extensions are required. However, some use cases dictate that aggregates only be materialized when their inputs are complete, such as queries for which partial results are too unstable to be of any use, such a query which determines if a numeric sum is even or odd. ==These still benefit from watermark-driven materialization even when consumed as a table==. | **完整性延迟**：事件时间窗口提供了一种将**==无界关系（realtion）==**切成有限时间块的方法，对于某些用例，**==窗口聚合的最终一致性==**就足够了，不需要进一步扩展。然而，有些用例要求聚合只有在其输入完整后才**物化**，例如部分结果太不稳定而无法使用的查询、或是确定数字和是偶数还是奇数的查询。即使作为表使用，这些仍然受益于水位驱动的物化。 |
| Recall again our query from **Listing 4** where we queried the table version of our relation at 8:13. That query presented a partial result for each window, capturing the highest priced items for each tumbling window at that point in processing time. For use cases where presenting such partial results is undesirable, we propose the syntax EMIT AFTER WATERMARK to ensure the <u>**table view**</u> would ==<u>only materialize rows whose input data were complete==</u>. In that way, our query at 8:13 would return an empty table: | 再次回忆一下<u>==清单4==</u>中的查询，我们在8:13查询了关系的表版本。该查询为每个窗口显示一个部分结果，在处理时间的该点为每个滚动窗口捕获价格最高的投标。对于不希望显示这种部分结果的用例，建议使用`EMIT AFTER WATERMARK`语法，以确保**<u>表视图</u>**只物化==<u>输入数据完整的行</u>==。这样，我们在8:13的查询将返回一个空表： |
| **Extension 5 (Materialization Delay: Completeness)**. When a query has an EMIT AFTER WATERMARK modifier, ==only complete rows from the results are materialized==. | **Extension 5 (Materialization Delay: Completeness)**：当查询具有`EMIT AFTER WATERMARK`修饰符时，==仅物化结果中的完整行==。 |
| *Periodic delays*: The second delayed materialization use case we care about revolves around managing the verbosity of an eventually consistent STREAM changelog. ==The default STREAM rendering, as we saw above, provides updates every time any row in the relation changes==. For high volume streams, such a changelog can be quite verbose. *In those cases, it is often desirable to limit how frequently aggregates in the relation are updated*. To do so, we propose the addition of an AFTER DELAY modifier to the EMIT clause, which dictates a delay imposed on materialization after a change to a given aggregate occurs, for example: | **周期性延迟**：我们关心的==第二个延迟物化用例==围绕着==管理最终一致的**流**变更日志的==详细程度。如上所述，默认的**流**呈现是，==关系中每次任何行发生更改时提供更新==。对于大流量，这样的更改日志可能非常冗长。在这些情况下，通常需要限制关系中聚合更新的频率。为此，我们建议在`EMIT`子句中添加`AFTER DELAY`修饰符，该修饰符指示在给定聚合发生更改后对物化施加延迟，例如： |
| In this example, multiple updates for each of the windows are compressed together, <u>each within a six-minute delay from the first change to the row</u>.<br>*Extension 6 (Periodic Materialization)*. When a query has EMIT AFTER DELAY d, rows are materialized with period d (instead of continuously). | 在此示例中，每个窗口的多个更新被压缩在一起，==<u>每个更新都在从第一次更改到该行的六分钟延迟之内</u>==。<br/>**扩展6（周期性==物化==）**。 当查询带有`EMIT AFTER DELAY d`后，行将以周期**d**（而不是连续）物化。 |
| It’s also possible to combine AFTER DELAY modifiers with AFTER WATERMARK modifiers to provide the early/on-time/late pattern [6] of repeated periodic updates for <u>partial result rows</u>, followed by a single on-time row, followed by repeated periodic updates for any <u>late rows</u>.<br>*Extension 7 (<u>CombinedMaterialization Delay</u>)*. When a query has EMIT AFTER DELAYd AND AFTER WATERMARK, <u>==rows are materialized==</u> with period d as well as when complete. | `还可以将AFTER DELAY`修改器与`AFTER WATERMARK`修改器结合使用，以`early`/`on-time`/`late`的模式[6]提供针对<u>部分结果行</u>的重复性周期更新、随后是单个==<u>准时的行</u>==，再随后是重复地周期性更新<u>延迟的行</u>。<br>扩展7（==<u>组合物化延迟</u>==）。 当查询具有`EMIT AFTER DELAY d` 和 `AFTER WATERMARK时，将以周期d，以及在数据完整时==<u>物化行</u>==。 |
| 7. SUMMARY                                                   |                                                              |
| Streaming SQL is an exercise in manipulating relations over time. <u>The large body of streaming SQL literature combined with recent efforts in the modern streaming community</u> form a strong foundation for **basic streaming semantics**, but room for improvement remains in the dimensions of <u>usability</u>, <u>flexibility</u>, and <u>robust event-time processing</u>.We believe that the three contributions proposed in this paper, (1) pervasive use of time-varying relations, (2) robust event-time semantics support, and (3) materialization control can substantially improve the ease-of-use of streaming SQL. Moreover, ==they will broaden the menu of available operators== to not only include <u>the full suite of point-in-time relational operators</u> available in standard SQL today, but also extend the capabilities of the language to operators that function over time to shape when and how <u>**relations**</u> evolve. | 流式SQL是随着时间推移处理关系的一种练习。<u>大量的流式SQL文献以及现代流社区中的最新努力</u>相结合，为**基本流语义**奠定了坚实的基础，但在<u>可用性</u>、<u>灵活性</u>和<u>健壮的事件时间处理</u>方面仍存在改进的空间，我们相信这三个方面 本文提出的贡献包括：（1）时变关系的广泛使用，（2）健壮的事件时间语义支持，（3）物化控制可以大大提高流SQL的易用性。此外，==他们将拓宽可用运算符的菜单==，不仅包括标准SQL中现在可用的<u>全套时间点关系运算符</u>，而且还将语言的功能扩展到随时间变化的运算符，以形成**<u>关系</u>**何时和如何发展。 |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |



